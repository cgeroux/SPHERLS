#!/usr/bin/env python

import datafile
import optparse as op
import make_profiles
import glob
import numpy as np
import sys
import os
import disect_filename
import parser
from math import *
import xml.etree.ElementTree as xml
import parse_formula
import mywarnings
import warnings
from myExceptions import *

def parseOptions():
  #note: newlines are not respected in the optparse description string :(, maybe someday will use
  #argparse, which does allow for raw formating (repects indents, newlines etc.)
  
  #setup command line parser
  '''This is out of date, needs to be updated to reflect new additions'''
  parser=op.OptionParser(usage="Usage: %prog [options] XMLFILE"
    ,version="%prog 1.0",description=r"Reads in the XMLFILE which specifies how the plot is to be "
    +"made and generates the plot of plots accordingly.")
    
  #these options apply globaly
  parser.add_option("-s","--show",dest="show",action="store_true",default=False
    ,help="Display plot to x11 display rather than saving to a file.")
  parser.add_option("-f","--file",dest="file",action="store_true",default=False
    ,help="Instead of plotting the data will be written to an ascii file.")
  parser.add_option("--dpi",dest="dpi",type="float",default=100
    ,help="Sets the dots per inch of the figure [default: %default]")
  parser.add_option("--space-axis-evenly",action="store_true",dest="spaceAxisEvenly"
    ,help="Will give the same amount of space per x-axis, instead of per plot. [not default]."
    ,default=False)
  
  #should likely be per plot, at the momement they are across all plots
  parser.add_option("--zone-index-from-center",dest="zoneIndexFromCenter",
    help="Specifies the radial zone at which to plot the desired column should starts with the "
    "center zone equal to zero and the zone number increasing towards the surface"
    ,action="store_true",default=False)
  parser.add_option("--fig-width",dest="figWidth",type="float",default=15
    ,help="Set the width of the figure [default: %default]")
  parser.add_option("--fig-height",dest="figHeight",type="float",default=9
    ,help="Set the height of the figure [default: %default]")
  
  make_profiles.addParserOptions(parser)
  
  #parse command line options
  return parser.parse_args()
class Curve:
  '''This class holds all the information for a curve on a plot.'''
  def __init__(self,element,type,curveIndex):
    
    '''This method initilizes a curve object, the type parameter allows checking curve syntax 
    against axis syntax to see if they match.'''
    
    self.nColumn=None
    self.zone=None
    self.nCurveIDForZoneRef=None
    self.y=[]
    self.index=[]
    self.bTime=None
    self.formulaOrig=None
    self.code=None
    self.style=""
    self.color=""
    self.markersize=3.0
    self.linewidth=1.0
    self.testZoneAdjust=False#triggered first time zoning is adjusted so doesn't adjust it every load
    self.label=None
    self.ID=None
    self.indexOfLastFileLoad=-1
    
    #set curve style
    if element.get("style")!=None:
      self.style=element.get("style")
    #else:
      #self.style="-"
    
    #set curve color
    if element.get("color")!=None:
      self.color=element.get("color")
    #else:
      #self.color="k"
      
    #set curve label
    if element.get("label")!=None:
      self.label=element.get("label")
      
    #set curve id
    if element.get("id")!=None:
      self.ID=element.get("id")
    
    #get marker size
    if element.get("markersize")!=None:
      if element.get("markersize").isdigit():
        self.markersize=float(element.get("markersize"))
      else:
        print "\"markersize\" must be a float, got \"",element.get("markersize"),"\""
    
    #get linewidth
    if element.get("linewidth")!=None:
      if element.get("linewidth").isdigit():
        self.linewidth=float(element.get("linewidth"))
      else:
        print "\"linewidth\" must be a float, got \"",element.get("linewidth"),"\""
    
    #set that the curve is a time, or profile curve
    if type=="time":
      self.bTime=True
    else:
      self.bTime=False
    
    #if it is a time axis, make sure we know which radial zone to plot from
    if self.bTime:
      if element.get("radialZone")!=None and element.get("radialZone")!="":
        if element.get("radialZone")=="max":
          self.zone="max"
        elif element.get("radialZone")=="min":
          self.zone="min"
        elif len(element.get("radialZone"))>12:
          if element.get("radialZone")[0:12]=="sameascurve:":
            self.zone=element.get("radialZone")[12:]
        elif element.get("radialZone").isdigit():
          self.zone=element.get("radialZone")
        else:
          print "Attribute \"radialZone\" set to \"",element.get("radialZone"),"\" expecting "\
            +"either a zone number, \"max\", or \"min\""
          quit()
      else:
        print "Attribute \"radialZone\" must be set for a curve in an axis of type=\"time\""
        quit()
    
    #create formula and code from the formula, as well as which columns are referenced and weather 
    #they are shifted in i
    [self.formulaOrig,self.formula,self.nColumn,self.nRowShift,self.code]\
      =parse_formula.getFormula(element.text)
  def load(self,fileData,options,dataSet,nFileCount):
    """This method adds a y value and index to the curve for the current 
    fileData."""
    
    if self.indexOfLastFileLoad!=nFileCount:#prevents loading the same file twice
      try:
        if self.zone=="max":
          
          #find largest value in column and use that
          nIndex=0
          
          #find first non-empty value
          while parse_formula.getY(self.nRowShift,self.nColumn,fileData,self.code,nIndex)==None:
            nIndex=nIndex+1
            if nIndex>len(fileData.fColumnValues)-1:
              warnings.warn("could find non-empty value in column \""+str(self.nColumn)
                +"\" of file \""+fileData.sFileName+"\"")
              break
            
          yTemp=parse_formula.getY(self.nRowShift,self.nColumn,fileData,self.code,nIndex)
          yIndexTemp=0
          for i in range(nIndex,len(fileData.fColumnValues)-1):
            yTest=parse_formula.getY(self.nRowShift,self.nColumn,fileData,self.code,i)
            if yTest>yTemp:
              yTemp=yTest
              yIndexTemp=i
          self.y.append(yTemp)
          self.index.append(yIndexTemp)
          if self.ID=="DelT" or self.ID=="L_con" or self.ID=="u-u0_max" or self.ID=="u-u0_atdt":
            print yIndexTemp,fileData.sHeader,self.ID
        elif self.zone=="min":
          #find smallest value in column and use that
          nIndex=0
          while parse_formula.getY(self.nRowShift,self.nColumn,fileData,self.code,nIndex)==None:
            nIndex=nIndex+1
            if nIndex>len(fileData.fColumnValues)-1:
              warnings.warn("could find non-empty value in column \""+str(self.nColumn)
                +"\" of file \""+fileData.sFileName+"\"")
              break
          yTemp=parse_formula.getY(self.nRowShift,self.nColumn,fileData,self.code,nIndex)
          yIndexTemp=0
          for i in range(nIndex,len(fileData.fColumnValues)-1):
            testY=parse_formula.getY(self.nRowShift,self.nColumn,fileData,self.code,i)
            if testY<yTemp:
              yTemp=testY
              yIndexTemp=i
          self.y.append(yTemp)
          self.index.append(yIndexTemp)
        elif self.zone==None and self.bTime==False:#this will be a series of y's as a function of time,
          #creating a 2D list instead of a 1D list
          yTemp=[]
          for i in range(len(fileData.fColumnValues)):
            yTemp.append(parse_formula.getY(self.nRowShift,self.nColumn,fileData,self.code,i))
          self.y.append(yTemp)
        elif self.zone==None:
          raise Exception("If zone="+str(self.zone)+" is \"None\" then it shouldn't be a time curve"\
            +" and thus the if above should have been flagged first, something strange is going on"\
            +" here")
        elif self.zone.isdigit():
          if not self.testZoneAdjust:
            if not options.zoneIndexFromCenter:
              zone=len(fileData.fColumnValues)-1-int(self.zone)
              
              #if right at the surface, and the zone is a non-interface, should move in
              while parse_formula.getY(self.nRowShift,self.nColumn,fileData,self.code,zone)==None:
                zone=zone-1
              self.zone=str(zone)
            self.testZoneAdjust=True
          self.y.append(parse_formula.getY(self.nRowShift,self.nColumn,fileData,self.code,int(self.zone)))
          self.index.append(int(self.zone))
        else:#check to see if it is a curve ID
          curveTemp=dataSet.getCurve(self.zone)
          if curveTemp!=None:
            
            #check that curve has been loaded already
            if curveTemp.indexOfLastFileLoad!=nFileCount:
              curveTemp.load(fileData,options,dataSet,nFileCount)
            
            #get y
            zone=curveTemp.index[len(curveTemp.index)-1]
            self.y.append(parse_formula.getY(self.nRowShift,self.nColumn,fileData,self.code,int(zone)))
            self.index.append(int(zone))
            
          else:
            print "zone spedificiation \""+str(self.zone)+"\" is not \"max\", \"min\", a radial index, or curve id"
        self.indexOfLastFileLoad=nFileCount
      except ValueError as anException:
        print "ValueError:", anException
        print "In curve formula:",self.formulaOrig
        quit()
class Plot:
  """This class holds all the information for a single plot
  
  namely the list of curves for that plot.
  
  """
  
  def __init__(self,element,type):
    """This method initlizes the plot object
    
    """
    
    self.ylabel=None
    self.curves=[]
    self.limits=None
    self.grid=None
    self.bMinorTics=False
    self.legendloc=1
    self.autoLimits=[True,True]
    
    #check for grid setting
    if element.get("grid")!=None:
      if element.get("grid").lower() in ["major","minor","both"]:
        self.grid=element.get("grid").lower()
      else:
        print "Grid type for plot unrecognized \"",element.get("grid"),"\" should be \"major\","\
          +" \"minor\", or \"both\"."
        quit()
    
    #check if using minor tics
    if element.get("yminortics")!=None:
      if element.get("yminortics").lower() in ["true","1","t","yes","y"]:
        self.bMinorTics=True
    
    #get ylabel
    if element.get("ylabel")!=None and element.get("ylabel")!="":
      self.ylabel=element.get("ylabel")
    
    #get range
    yMin=None
    if element.get("ymin")!=None and element.get("ymin")!="":
      yMin=float(element.get("ymin"))
      self.autoLimits[0]=False
    yMax=None
    if element.get("ymax")!=None and element.get("ymax")!="":
      yMax=float(element.get("ymax"))
      self.autoLimits[1]=False
    self.limits=[yMin,yMax]
    
    #get ledgend location
    if element.get("legendloc")!=None and element.get("legendloc")!="":
      self.legendloc=int(element.get("legendloc"))
    
    #add curves to plot
    curveElements=element.findall("curve")
    curveIndex=0
    for curveElement in curveElements:
      self.curves.append(Curve(curveElement,type,curveIndex))
      curveIndex+=1
  def load(self,fileData,options,dataSet,nFileCount):
    """Loads the data for a plot
    
    y-data is stored in the curves, and sets the ylabel from the first
    file read in
    
    """
    
    if self.ylabel==None:#if not already set, this should be triggered only on the first load
      
      for curve in self.curves:
        
        #load curve data
        curve.load(fileData,options,dataSet,nFileCount)
        
        #add zone number to suffix
        suffix=''
        if curve.bTime:
          suffix="_"+curve.zone
        
        #add curve reference to suffix
        if curve.nCurveIDForZoneRef!=None:
          suffix='_ref('+str(curve.nCurveIDForZoneRef)+')'
        
        #set ylabel
        if self.ylabel==None:
          if isinstance(curve.nColumn,int):
            self.ylabel=fileData.sColumnNames[curve.nColumn]+suffix
          else:
            self.ylabel=curve.formulaOrig+suffix
        else:
          if isinstance(curve.nColumn,int):
            self.ylabel=self.ylabel+", "+fileData.sColumnNames[curve.nColumn]+suffix
          else:
            self.ylabel=self.ylabel+", "+curve.formulaOrig+suffix
    else:#for all subsequent files
      for curve in self.curves:
        curve.load(fileData,options,dataSet,nFileCount)
  def setLimits(self,x,xlimits,bTimeAxis):
    """Sets the y limits
    
    from the maximum, and minimum y values in the curves on
    the plot in the xrange specified, over all files.
    
    """
    
    #if both y limits were already set in configuraiton file, don't set anything
    if self.autoLimits[0]==False and self.autoLimits[1]==False:
      return
    
    #Only upper bound set
    if xlimits[1]==None:
      xLimitsTemp=[xlimits[0],sys.float_info.max]
      
    #Only lower bound set
    elif xlimits[0]==None:
      xLimitsTemp=[-1.0*sys.float_info.max,xlimits[1]]
    #Both Bounds set
    else:
      xLimitsTemp=xlimits
    
    minyInCurves=sys.float_info.max
    maxyInCurves=-1.0*sys.float_info.max
    
    if bTimeAxis:#axis is a time axis
      
      for curve in self.curves:
        
        #check that num x, and num y match for each curve, for each file
        if len(x)!=len(curve.y):
          raise Exception("number of x points for axis, and number of y points"\
            +" for curve don't match")
        
        for j in range(len(curve.y)):
          
          #if in xrange
          if xLimitsTemp[0]<=x[j] and x[j]<=xLimitsTemp[1]:
            
            #keep smallest y
            if minyInCurves> curve.y[j] and curve.y[j]!=None:
              minyInCurves=curve.y[j]
            
            #keep largest y
            if maxyInCurves< curve.y[j] and curve.y[j]!=None:
              maxyInCurves=curve.y[j]
    else:#axis is a profile axis
      
      for curve in self.curves:
        
        #loop over every file
        for i in range(len(curve.y)):
          
          #check that num x, and num y match for each curve, for each file
          if len(x[i])!=len(curve.y[i]):
            raise Exception("number of x points for axis, and number of y points"\
              +" for curve don't match")
          
          for j in range(len(curve.y[i])):
            
            #if in xrange
            if xLimitsTemp[0]<=x[i][j] and x[i][j]<=xLimitsTemp[1]:
              
              #keep smallest y
              if minyInCurves> curve.y[i][j] and curve.y[i][j]!=None:
                minyInCurves=curve.y[i][j]
              
              #keep largest y
              if maxyInCurves< curve.y[i][j] and curve.y[i][j]!=None:
                maxyInCurves=curve.y[i][j]
      
    #set only limits which are not set in configuration file
    if self.autoLimits[0]==True and self.autoLimits[1]==True:
      self.limits=[minyInCurves,maxyInCurves]
    elif self.autoLimits[0]==True:
      self.limits[0]=minyInCurves
    elif self.autoLimits[1]==True:
      self.limits[1]=maxyInCurves
class Axis:
  '''This class holds all the information needed for a particular x-axis. An axis can either be 
  either of time, or of some column in the data files.'''
  
  def __init__(self,element,options):
    '''This function initizalizes the axis object.'''
    
    self.plots=[]
    self.bTime=False
    self.period=None
    self.nColumn=None
    self.xlabel=None
    self.x=[]
    self.formulaOrig=None
    self.formula=None
    self.phase=[]
    self.code=None
    self.limits=None
    self.bMinorTics=False
    
    #check for grid setting
    if element.get("grid")!=None:
      if element.get("grid").lower() in ["major","minor","both"]:
        self.grid=element.get("grid").lower()
      else:
        print "Grid type for plot unrecognized \"",element.get("grid"),"\" should be \"major\","\
          +" \"minor\", or \"both\"."
        quit()
    
    #check if using minor tics
    if element.get("xminortics")!=None:
      if element.get("xminortics").lower() in ["true","1","t","yes","y"]:
        self.bMinorTics=True
    
    #get type of axis
    if element.get("type")=="time":
      self.bTime=True
    elif element.get("type")=="profile":
      self.bTime=False
    else:
      print "axis type is \"",element.get("type"),"\" must be either \"profile\" or \"time\"."
      quit()
    
    #if time axis set period if there is one
    if self.bTime and element.get("period") != None:
      self.period=float(element.get("period"))
    
    #get xlabel
    self.xlabel=element.get("xlabel")
    if self.xlabel==None and self.bTime:
      if self.period!=None:
        self.xlabel="phase"
      else:
        self.xlabel="t [s]"
    
    #get xrange
    xMin=None
    if element.get("xmin")!=None and element.get("xmin")!="":
      xMin=float(element.get("xmin"))
    xMax=None
    if element.get("xmax")!=None and element.get("xmax")!="":
      xMax=float(element.get("xmax"))
    self.limits=[xMin,xMax]
    
    #get column if not a time axis
    if not self.bTime:
      [self.formulaOrig,self.formula,self.nColumn,self.nRowShift,self.code]\
        =parse_formula.getFormula(element.get("column"))
    
    #add plots to axis
    plotElements=element.findall("plot")
    for plotElement in plotElements:
      type="profile"
      if self.bTime:
        type="time"
      self.plots.append(Plot(plotElement,type))
  def load(self,fileData,options,dataSet,nFileCount):
    '''This function loads the values needed for the x-axis data from the fileData argument'''
    
    if self.bTime:#add time
      
      #these are required in case the time isn't space seperated
      fileHeader=fileData.sHeader.split("=")
      indexBracket=fileHeader[1].find("[s]")
      self.x.append(float(fileHeader[1][0:indexBracket]))
      
      #set phase
      if self.period!=None:
        self.phase.append((float(fileHeader[1][0:indexBracket])-self.x[0])/self.period)
        
    else:#assuming if it isn't time data, it is column data
      if self.nColumn!=None:
        if self.xlabel==None:
          if isinstance(self.nColumn,int):
            self.xlabel=fileData.sColumnNames[self.nColumn]
          else:
            self.xlabel=self.formulaOrig
        xTemp=[]
        for i in range(len(fileData.fColumnValues)):
          xTemp.append(parse_formula.getY(self.nRowShift,self.nColumn,fileData,self.code,i))
        self.x.append(xTemp)
          
    #load plots
    for plot in self.plots:
      plot.load(fileData,options,dataSet,nFileCount)
    
    #set plot limits
    for plot in self.plots:
      plot.setLimits(self.x,self.limits,self.bTime)
class DataSet:
  '''This class holds all the information for a single dataSet, which includes the baseFileName of 
  the dataset, the range of the dataSet (start-end), the times and phases of the files within the 
  range of the dataSet, and the plots made from the dataSet.'''
  
  def __init__(self,element,options):
    '''Initilizes the dataSet by setting baseFileName, start, end, and intilizing plots from an xml 
    element'''
    
    #set some initial values
    self.baseFileName=None
    self.start=None
    self.end=None
    self.axes=[]
    self.nNumFiles=None
    self.fileIndices=[]
    self.hasNonTimeAxis=False
    
    [self.start,self.end,self.baseFileName]=disect_filename.disectFileName(element.attrib["fileRange"])
    
    #get equation of state file if one specified
    eosFileElement=element.findall("eosFile")
    if len(eosFileElement)>1:
      warnings.warn("more than one \"eosFile\" node, ignoring all but first node")
    if len(eosFileElement)>0:
      self.eosFile=eosFileElement[0].text
    else:
      self.eosFile=None
    
    #add axes to dataset
    axisElements=element.findall("axis")
    for axisElement in axisElements:
      axis=Axis(axisElement,options)
      self.axes.append(axis)
      if not axis.bTime:
        self.hasNonTimeAxis=True
  def load(self,options):
    '''Loads the dataSet, this means that it sets, time, phases, and plots data'''
    
    #make sure that all the combined binary files within range of dataset have profiles made
    fileName=self.baseFileName+"["+str(self.start)+"-"+str(self.end)+"]"
    try:
      failedFiles=make_profiles.make_fileSet(fileName,options)
    except NoFilesFound as e:
      
      #it is OK if their aren't any combined binary files to make profiles from
      #so long as there are actually some profiles
      print e.message
      failedFiles=[]
    
    if len(failedFiles)>0:
      for failedFile in failedFiles:
        print failedFile
    
    #get and sort profiles within range of dataset
    extension="_pro"+".txt"
    filesExistProfiles=glob.glob(self.baseFileName+"*"+extension)
    filesExistProfiles.sort()
    files=[]
    print "found "+str(len(filesExistProfiles))+" profile files"
    for i in range(0,len(filesExistProfiles),options.frequency):
      file=filesExistProfiles[i]
      intOfFile=int(file[len(self.baseFileName):len(file)-len(extension)])
      if intOfFile>=self.start and intOfFile<self.end:
        files.append(file)
    if len(files)==0:
      raise Exception("no files found in range ["+str(self.start)+"-"
        +str(self.end)+"]")
    
    self.nNumFiles=len(files)
    
    #create time, phase and curve y's for dataset
    nFileCount=0
    for file in files:
      
      #get file index
      temp=file[file.find("_t")+2:]
      self.fileIndices.append(temp[:temp.find("_pro")])
      
      #read in profile
      print "reading in profile ",file,str(nFileCount+1)+"/"+str(self.nNumFiles)+" ..."
      fileData=datafile.DataFile()
      fileData.readFile(file)
      
      #load x-axis data and y-data
      for axis in self.axes:
        axis.load(fileData,options,self,nFileCount)
      nFileCount=nFileCount+1
  def getCurve(self,ID):
    '''Returns a curve object that has ID, ID'''
    
    for axis in self.axes:
      for plot in axis.plots:
        for curve in plot.curves:
          if curve.ID==ID:
            return curve
    return None
def plot(dataSets,options,title):
  
  #set import options based on weather it will saved to a file, or sent to x11
  #print "interactive backends=",matplotlib.rcsetup.interactive_bk
  #print "non-interactive backends=",matplotlib.rcsetup.non_interactive_bk
  #print "all backends=",matplotlib.rcsetup.all_backends
  
  import matplotlib
  if not options.show:
    matplotlib.use("Agg")
  import matplotlib.pyplot as plt
  
  from matplotlib.gridspec import GridSpec
  
  #count number of axes in all plots, this number will be the same for all plots.
  nNumAxes=0
  for dataSet in dataSets:
    nNumAxes=nNumAxes+len(dataSet.axes)
  heightAxis=((options.figTop-options.figBottom)-options.axisSpacing*(nNumAxes-1.0))/nNumAxes
  
  #count number of plots
  nNumPlots=0
  for dataSet in dataSets:
    for axis in dataSet.axes:
      nNumPlots=nNumPlots+len(axis.plots)
  heightPlot=((options.figTop-options.figBottom)-options.axisSpacing*(nNumAxes-1.0))/nNumPlots
  
  #figure out how many output files will be made, will match the largest number of files read in of
  #all dataSets
  nMaxNumFiles=1
  bNonTimeAxisAny=False
  for dataSet in dataSets:
    #for axis in dataSet.axes:
    #  if not axis.bTime:
    #    bNonTimeAxis=True
    if dataSet.hasNonTimeAxis:
      bNonTimeAxisAny=True
      if nMaxNumFiles<dataSet.nNumFiles:
        nMaxNumFiles=dataSet.nNumFiles
  
  #create plots
  fileCount=0
  fileStart=0
  for i in range(nMaxNumFiles):
    
    fig=plt.figure(figsize=(options.figWidth,options.figHeight))
    axisCount=0
    nTotalPlotCount=1
    dataSetCount=0
    ax=[]
    gs=[]
    top=options.figTop
    plotDataForFile=[]
    fileHeader=""
    #add title
    if title!="":
      tempTitle=title
      count=0
      for dataSet in dataSets:
        for axisMine in dataSet.axes:
          if axisMine.bTime:
            if fileCount<len(axisMine.x):
              time=axisMine.x[fileCount]
              timeStr=format(time,"0.4e")
              tempTitle=tempTitle.replace("\\time"+str(count),timeStr)
              break
              
              if axisMine.period!=None:
                phase=axisMine.phase[fileCount]
                phaseStr=format(phase,"0.4e")
                tempTitle=tempTitle.replace("\phase"+str(count),phaseStr)
                break
        indexStr="\index"+str(count)
        if fileCount<len(dataSet.fileIndices):
          tempTitle=tempTitle.replace(indexStr,str(dataSet.fileIndices[fileCount]))
        count+=1
        
      #
      fig.suptitle(tempTitle)
    
    for dataSet in dataSets:
      if i<dataSet.nNumFiles:
        for axisMine in dataSet.axes:
          gs.append(GridSpec(len(axisMine.plots),1))
          bottom=top-heightPlot*(len(axisMine.plots))
          if options.spaceAxisEvenly:
            top=options.figTop-axisCount*(heightAxis+options.axisSpacing)
            bottom=options.figBottom+(nNumAxes-1.0-axisCount)*(heightAxis+options.axisSpacing)
          gs[axisCount].update(top=top,bottom=bottom,hspace=0.0)
          
          #for each plot
          nPlotCount=0
          for plot in axisMine.plots:
            
            #create a subplot
            ax.append(plt.subplot(gs[axisCount][nPlotCount,0]))
            
            #set minor axis tics
            if axisMine.bMinorTics:
              ax[nTotalPlotCount-1].xaxis.set_minor_locator(matplotlib.ticker.AutoMinorLocator())
            if plot.bMinorTics:
              ax[nTotalPlotCount-1].yaxis.set_minor_locator(matplotlib.ticker.AutoMinorLocator())
            
            #set grid settings
            if plot.grid!=None:
              ax[nTotalPlotCount-1].grid(True, which=plot.grid)
            else:
              ax[nTotalPlotCount-1].grid(False)
            
            #for each curve in the plot
            lines=[]
            labels=[]
            if axisMine.bTime:
              curveCount=0
              for curve in plot.curves:
                
                #plot the curve
                if axisMine.period!=None:#use phase instead of time if period is given
                  temp=ax[nTotalPlotCount-1].plot(axisMine.phase,curve.y,str(curve.color)+str(curve.style)
                    ,markersize=curve.markersize,linewidth=curve.linewidth)
                  if options.file:
                    ylabel=""
                    if plot.ylabel!=None:
                      ylabel+=plot.ylabel.replace(" ","_")
                    if curve.label!=None:
                      ylabel+="_"+curve.label.replace(" ","_")
                    fileHeader+=axisMine.xlabel.replace(" ","_")+" "+ylabel+" "
                    plotDataForFile.append([axisMine.phase,curve.y])
                  if curve.label!=None and curve.label!="":
                    lines.append(temp[0])
                    labels.append(curve.label)
                  if bNonTimeAxisAny:#only need bar, if there are non-time axes in dataSet
                    limits=ax[nTotalPlotCount-1].axis()
                    xTemp=[axisMine.phase[fileCount],axisMine.phase[fileCount]]
                    yTemp=[limits[2],limits[3]]
                    if plot.limits[0]!=None:
                      yTemp[0]=plot.limits[0]
                    if plot.limits[1]!=None:
                      yTemp[1]=plot.limits[1]
                    ax[nTotalPlotCount-1].plot(xTemp,yTemp,'r-',linewidth=curve.linewidth)
                    if options.file:
                      ylabel=""
                      if plot.ylabel!=None:
                        ylabel+=plot.ylabel.replace(" ","_")
                      if curve.label!=None:
                        ylabel+="_"+curve.label.replace(" ","_")
                      fileHeader+=axisMine.xlabel.replace(" ","_")+" "+ylabel+" "
                      plotDataForFile.append([xTemp,yTemp])
                else:
                  temp=ax[nTotalPlotCount-1].plot(axisMine.x,curve.y,str(curve.color)+str(curve.style)
                    ,markersize=curve.markersize,linewidth=curve.linewidth)
                  if options.file:
                    ylabel=""
                    if plot.ylabel!=None:
                      ylabel+=plot.ylabel.replace(" ","_")
                    if curve.label!=None:
                      ylabel+="_"+curve.label.replace(" ","_")
                    fileHeader+=axisMine.xlabel.replace(" ","_")+" "+ylabel+" "
                    plotDataForFile.append([axisMine.x,curve.y])
                  if curve.label!=None and curve.label!="":
                    lines.append(temp[0])
                    labels.append(curve.label)
                  if bNonTimeAxisAny:#only need bar, if there are non-time axes in any of the dataSets
                    limits=ax[nTotalPlotCount-1].axis()
                    xTemp=[axisMine.x[fileCount],axisMine.x[fileCount]]
                    yTemp=[limits[2],limits[3]]
                    if plot.limits[0]!=None:
                      yTemp[0]=plot.limits[0]
                    if plot.limits[1]!=None:
                      yTemp[1]=plot.limits[1]
                    ax[nTotalPlotCount-1].plot(xTemp,yTemp,'r-',linewidth=curve.linewidth)
                    if options.file:
                      ylabel=""
                      if plot.ylabel!=None:
                        ylabel+=plot.ylabel.replace(" ","_")
                      if curve.label!=None:
                        ylabel+="_"+curve.label.replace(" ","_")
                      fileHeader+=axisMine.xlabel.replace(" ","_")+" "+ylabel+" "
                      plotDataForFile.append([xTemp,yTemp])
                curveCount=curveCount+1
            else:
              curveCount=0
              for curve in plot.curves:
                
                #plot the curve
                temp=ax[nTotalPlotCount-1].plot(axisMine.x[i],curve.y[i],str(curve.color)+str(curve.style)
                  ,markersize=curve.markersize,linewidth=curve.linewidth)
                if options.file:
                  ylabel=""
                  if plot.ylabel!=None:
                    ylabel+=plot.ylabel.replace(" ","_")
                  if curve.label!=None:
                    ylabel+="_"+curve.label.replace(" ","_")
                  fileHeader+=axisMine.xlabel.replace(" ","_")+" "+ylabel+" "
                  plotDataForFile.append([axisMine.x[i],curve.y[i]])
                if curve.label!=None and curve.label!="":
                  lines.append(temp[0])
                  labels.append(curve.label)
                curveCount=curveCount+1
            
            ax[nTotalPlotCount-1].set_xlim(axisMine.limits)
            ax[nTotalPlotCount-1].set_ylim(plot.limits)
            
            #set legend
            if len(lines)>0:
              ax[nTotalPlotCount-1].legend(lines,labels,loc=plot.legendloc)
            
            #remove x-axis labels
            if nPlotCount!=len(axisMine.plots)-1:
              plt.setp(plt.gca(), 'xticklabels', [])
            else:
              ax[nTotalPlotCount-1].set_xlabel(axisMine.xlabel)
            
            #set y-axis labels
            ax[nTotalPlotCount-1].set_ylabel(plot.ylabel)
            
            #remove top and bottom y-axis tic labels
            ax[nTotalPlotCount-1].yaxis.set_major_locator(matplotlib.ticker.MaxNLocator(prune='both'))
            
            #adjust hspace to be 0 so plots for the same x-axis will be tight
            nPlotCount=nPlotCount+1#resets every axis
            nTotalPlotCount=nTotalPlotCount+1#continues to increase for all plots
          
          top=bottom-options.axisSpacing
          axisCount=axisCount+1
      
    #done making plot
    if options.show:
      print "ploting file ",i," to screen, close for next plot"
      plt.show()
    else:
      [path,ext]=os.path.splitext(options.outputFile)
      if options.file:
        print __name__+":"+main.__name__+": saving figure "+str(i+1)+"/"+str(nMaxNumFiles)+" to file \""+path+"_"+str(fileCount\
          +options.startIndex)+".txt\" ..."
        f=open(path+"_"+str(fileCount)+".txt",'w')
        
        #write header to file
        f.write(fileHeader+"\n")
        
        #write info to file
        nIndex=0
        bContinue=True
        while bContinue:
          line=""
          bContinue=False
          for [x,y] in plotDataForFile:
            if nIndex<len(x):
              line+=str(x[nIndex])+" "
              bContinue=True
            else:
              line+="- "
            if nIndex<len(y):
              line+=str(y[nIndex])+" "
              bContinue=True
            else:
              line+="- "
          line+="\n"
          f.write(line)
          nIndex+=1
        f.close()
      else:
        supportedFileTypes=["png", "pdf", "ps", "eps", "svg"]
        if ext[1:] not in supportedFileTypes:
          print "File type \""+ext[1:]+"\" not suported. Supported types are ",supportedFileTypes\
            ," please choose one of those"
          quit()
        print __name__+":"+main.__name__+": saving figure "+str(i+1)+"/"+str(nMaxNumFiles)+" to file \""+path+"_"+str(fileCount\
          +options.startIndex)+ext+"\" ..."
        fig.savefig(path+"_"+str(fileCount+options.startIndex)+ext,format=ext[1:]
          ,transparent=False,dpi=options.dpi)#save to file
        plt.close(fig)
      
    fileCount=fileCount+1
def main():
  
  #parse command line options
  (options,args)=parseOptions()
  
  if len(args)==0:
    print "must supply an input file"
    quit()
  
  #get root element
  tree=xml.parse(args[0])
  root=tree.getroot()
  
  #set plot title
  title=""
  if root.get("title")!=None and root.get("title")!="":
    title=root.get("title")
    
  #set spacing between axes
  options.axisSpacing=0.05
  if root.get("axisSpacing")!=None and root.get("axisSpacing")!="":
    options.axisSpacing=float(root.get("axisSpacing"))
  
  #set location of top of the plot area
  options.figTop=0.95
  if root.get("figTop")!=None and root.get("figTop")!="":
    options.figTop=float(root.get("figTop"))
  
  #set location of bottom of the plot area
  options.figBottom=0.05
  if root.get("figBottom")!=None and root.get("figBottom")!="":
    options.figBottom=float(root.get("figBottom"))
  
  #set figure height
  if root.get("figHeight")!=None and root.get("figHeight")!="":
    options.figHeight=float(root.get("figHeight"))
  
  #set figure width
  if root.get("figWidth")!=None and root.get("figWidth")!="":
    options.figWidth=float(root.get("figWidth"))
    
  #set figure dpi
  if root.get("dpi")!=None and root.get("dpi")!="":
    options.dpi=int(root.get("dpi"))
  
  #set plot output
  if root.get("outputfile")!=None and root.get("outputfile")!="":
    options.outputFile=root.get("outputfile")
    [path,ext]=os.path.splitext(options.outputFile)
    supportedFileTypes=["png", "pdf", "ps", "eps", "svg"]
    if ext[1:] not in supportedFileTypes:
      print "File type \""+ext[1:]+"\" not suported. Supported types are ",supportedFileTypes," please choose one of those"
      quit()
  
  #get plot start index
  options.startIndex=0
  if root.get("outputFileStartIndex")!=None and root.get("outputFileStartIndex")!="":
    options.startIndex=int(root.get("outputFileStartIndex"))
  
  #get file frequency
  options.frequency=1
  if root.get("inputFileFrequency")!=None and root.get("inputFileFrequency")!="":
    options.frequency=int(root.get("inputFileFrequency"))
  
  #get list of dataSet elements
  dataSetElements=root.findall("dataSet")
  
  #initialize datasets
  dataSets=[]
  for dataSetElement in dataSetElements:
    dataSets.append(DataSet(dataSetElement,options))
  
  #load datasets
  i=0
  for dataSet in dataSets:
    print "reading in data set ",i
    dataSet.load(options)
    i=i+1
  
  #plot datasets
  plot(dataSets,options,title)
  
  return
if __name__ == "__main__":
  main()