/** @file
  
  This code is used to manipulate the outputfiles generated by SHPERLS.
*/
#include "main.h"
#include <math.h>
#include <iomanip>
#include "eos.h"

int main(int argc, char *argv[]){
  
  //turn on floating point exceptoins
  //feenableexcept(FE_DIVBYZERO | FE_INVALID | FE_OVERFLOW | FE_UNDERFLOW);//don't want underflow, that's ok
  feenableexcept(FE_DIVBYZERO | FE_INVALID | FE_OVERFLOW);
  
  signal(SIGFPE, fpSignalHandler);
  
  try{
    
    //process arguments
    if(argc<2){
      std::stringstream ssTemp;
      ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": must supply at "
        <<"leat a filename base\n\n";
      throw exception2(ssTemp.str(),SYNTAX);
    }
    int nFromFileType;
    int nToFileType;
    std::string sFileName;
    int nOperation=-1;
    int nPlane=-1;
    int nPlaneIndex=-1;
    for(int i=1;i<argc;i++){
      switch(argv[i][0]){
        case '-':{//is a flag
          switch(argv[i][1]){//what flag
            case 'c':{//convert between two file types
              
              nOperation=1;
              //check that there are enough arguments
              if(argc<3){//"exe name"+"-c"+"these arguments"
                std::stringstream ssTemp;
                ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
                  <<": too few arguments\n";
                throw exception2(ssTemp.str(),SYNTAX);
              }
              
              //get from file type
              nFromFileType=0;
              switch(argv[i+1][0]){
                case 'd':{//distributed
                  nFromFileType+=1;
                  break;
                }
                case 'c':{//collected
                  nFromFileType+=2;
                  break;
                }
                default:{//unknown
                  std::stringstream ssTemp;
                  ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
                    <<": unknown file type \""<<argv[i+1][0]
                    <<"\", should be either \"d\" or \"c\".\n";
                  throw exception2(ssTemp.str(),SYNTAX);
                }
              }
              switch(argv[i+1][1]){
                case 'b':{//binary
                  nFromFileType+=4;
                  break;
                }
                case 'a':{//ascii
                  nFromFileType+=8;
                  break;
                }
                default:{//unknown
                  std::stringstream ssTemp;
                  ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
                    <<": unknown file type \""<<argv[i+1][1]
                    <<"\", should be either \"b\" or \"a\".\n";
                  throw exception2(ssTemp.str(),SYNTAX);
                }
              }
              
              //get to file type
              nToFileType=0;
              switch(argv[i+1][2]){
                case 'd':{//distributed
                  nToFileType+=1;
                  break;
                }
                case 'c':{//collected
                  nToFileType+=2;
                  break;
                }
                default:{//unknown
                  std::stringstream ssTemp;
                  ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
                    <<": unknown file type \""<<argv[i+1][0]
                    <<"\", should be either \"d\" or \"c\".\n";
                  throw exception2(ssTemp.str(),SYNTAX);
                }
              }
              switch(argv[i+1][3]){
                case 'b':{//binary
                  nToFileType+=4;
                  break;
                }
                case 'a':{//ascii
                  nToFileType+=8;
                  break;
                }
                default:{//unknown
                  std::stringstream ssTemp;
                  ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
                    <<": unknown file type \""<<argv[i+1][1]
                    <<"\", should be either \"b\" or \"a\".\n";
                  throw exception2(ssTemp.str(),SYNTAX);
                }
              }
              
              i++;//skip next argument, already handled
              break;
            }
            case 'f':{//set formating
              switch(argv[i+1][0]){//which kind of formating do we want
                case 'f'://fixed formating
                  bScientific=false;//make sure scientific not set
                  i++;//skip next value
                  break;
                case 's'://scientific
                  bScientific=true;
                  i++;//skip next value
                  break;
                default:{
                  std::stringstream ssTemp;
                  ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
                    <<":uknown parameter "<<argv[i+1]<<" for flag "<<argv[i]
                    <<std::endl;
                  throw exception2(ssTemp.str(),SYNTAX);
                  break;
                }
              }
              break;
            }
            case 'p':{//set precision
              std::string sTemp;
              sTemp=argv[i+1];
              if(sTemp.find_first_not_of("0123456789")<sTemp.size()){
                std::stringstream ssTemp;
                ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
                  <<": precision given, "<<argv[i+1]
                  <<", is not an unsigned integer\n\n";
                throw exception2(ssTemp.str(),SYNTAX);
              }
              nPrecisionAscii=atoi(argv[i+1]);
              i++;//skip next value since already used
              break;
            }
            case 'a':{//make a radial profile
              
              nOperation=2;
              
              //check that there are enough arguments
              if(argc<3){//"exe name"+"-c"+"these arguments"
                std::stringstream ssTemp;
                ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
                  <<": too few arguments\n";
                throw exception2(ssTemp.str(),SYNTAX);
              }
              
              //get from file type
              nFromFileType=0;
              switch(argv[i+1][0]){
                case 'd':{//distributed
                  nFromFileType+=1;
                  break;
                }
                case 'c':{//collected
                  nFromFileType+=2;
                  break;
                }
                default:{//unknown
                  std::stringstream ssTemp;
                  ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
                    <<": unknown file type \""<<argv[i+1][0]
                    <<"\", should be either \"d\" or \"c\".\n";
                  throw exception2(ssTemp.str(),SYNTAX);
                }
              }
              switch(argv[i+1][1]){
                case 'b':{//binary
                  nFromFileType+=4;
                  break;
                }
                case 'a':{//ascii
                  nFromFileType+=8;
                  break;
                }
                default:{//unknown
                  std::stringstream ssTemp;
                  ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
                    <<": unknown file type \""<<argv[i+1][1]
                    <<"\", should be either \"b\" or \"a\".\n";
                  throw exception2(ssTemp.str(),SYNTAX);
                }
              }
              break;
            }
            case 's':{//make a 2D slice
              
              nOperation=3;
              
              //check that there are enough arguments
              if(argc<3){//"exe name"+"-c"+"these arguments"
                std::stringstream ssTemp;
                ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
                  <<": too few arguments\n";
                throw exception2(ssTemp.str(),SYNTAX);
              }
              
              //get from file type
              nFromFileType=0;
              switch(argv[i+1][0]){
                case 'd':{//distributed
                  nFromFileType+=1;
                  break;
                }
                case 'c':{//collected
                  nFromFileType+=2;
                  break;
                }
                default:{//unknown
                  std::stringstream ssTemp;
                  ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
                    <<": unknown file type \""<<argv[i+1][0]
                    <<"\", should be either \"d\" or \"c\".\n";
                  throw exception2(ssTemp.str(),SYNTAX);
                }
              }
              switch(argv[i+1][1]){
                case 'b':{//binary
                  nFromFileType+=4;
                  break;
                }
                case 'a':{//ascii
                  nFromFileType+=8;
                  break;
                }
                default:{//unknown
                  std::stringstream ssTemp;
                  ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
                    <<": unknown file type \""<<argv[i+1][1]
                    <<"\", should be either \"b\" or \"a\".\n";
                  throw exception2(ssTemp.str(),SYNTAX);
                }
              }
              
              //get plane 0,1,2
              nPlane=atoi(argv[i+2]);
              if(nPlane!=0&&nPlane!=1&&nPlane!=2){
                std::stringstream ssTemp;
                ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
                  <<": plane must be either 0, 1, or 2\n";
                throw exception2(ssTemp.str(),SYNTAX);
              }
              nPlaneIndex=atoi(argv[i+3]);
              if(nPlaneIndex<0){
                std::stringstream ssTemp;
                ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
                  <<": plane index must be a postive integer\n";
                throw exception2(ssTemp.str(),SYNTAX);
              }
              break;
            }
            case 't':{//calculate fourier transform
              nOperation=4;
              
              //check that there are enough arguments
              if(argc<3){//"exe -t fileName"
                std::stringstream ssTemp;
                ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
                  <<": too few arguments\n";
                throw exception2(ssTemp.str(),SYNTAX);
              }
              if(argv[i][2]=='l'){//not from a watchZone file but from a two column file
                nOperation=41;
              }
              break;
            }
            case 'h':{//display help
              printHelp();
              return 0;
              break;
            }
            case 'l':{
              nOperation=5;
              
              //check that there are enough arguments
              if(argc<3){//"exe name"+"-c"+"these arguments"
                std::stringstream ssTemp;
                ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
                  <<": too few arguments\n";
                throw exception2(ssTemp.str(),SYNTAX);
              }
              
              //get from file type
              nFromFileType=0;
              switch(argv[i+1][0]){
                case 'd':{//distributed
                  nFromFileType+=1;
                  break;
                }
                case 'c':{//collected
                  nFromFileType+=2;
                  break;
                }
                default:{//unknown
                  std::stringstream ssTemp;
                  ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
                    <<": unknown file type \""<<argv[i+1][0]
                    <<"\", should be either \"d\" or \"c\".\n";
                  throw exception2(ssTemp.str(),SYNTAX);
                }
              }
              switch(argv[i+1][1]){
                case 'b':{//binary
                  nFromFileType+=4;
                  break;
                }
                case 'a':{//ascii
                  nFromFileType+=8;
                  break;
                }
                default:{//unknown
                  std::stringstream ssTemp;
                  ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
                    <<": unknown file type \""<<argv[i+1][1]
                    <<"\", should be either \"b\" or \"a\".\n";
                  throw exception2(ssTemp.str(),SYNTAX);
                }
              }
              break;
            }
            default:{//default is to display help
              std::stringstream ssTemp;
              ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
                <<": unknown flag \""<<argv[i]<<"\""<<std::endl<<std::endl;
              throw exception2(ssTemp.str(),SYNTAX);
              break;
            }
          }
          break;
        }
        default:{//is filename
          if(i==1){
            std::stringstream ssTemp;
            ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
              <<": currently no default operation set, must specify flags\n\n";
            throw exception2(ssTemp.str(),SYNTAX);
          }
          sFileName=argv[i];
        }
      }
    }
    
    //check to make sure a base file name was specified
    if(sFileName.size()==0){//no file name set
      std::stringstream ssTemp;
      ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
        <<": no file name specified.\n";
      throw exception2(ssTemp.str(),SYNTAX);
    }
    
    switch(nOperation){
      case 1:{//do a conversion
        switch(nFromFileType){
          case 5:{//from db
            switch(nToFileType){
              case 5:{//to db
                std::stringstream ssTemp;
                ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
                  <<": nothing to do. Convert from and to"
                  <<" file types the same.\n";
                throw exception2(ssTemp.str(),SYNTAX);
                break;
              }
              case 9:{//to da
                convertDistBinToAscii(sFileName);
                break;
              }
              case 6:{//to cb
                combineBinFiles(sFileName);
                break;
              }
              case 10:{//to ca
                combineBinFiles(sFileName);
                convertCollBinToAscii(sFileName);
                break;
              }
              default:{
                std::stringstream ssTemp;
                ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
                  <<": unknown file type to convert to. \n";
                throw exception2(ssTemp.str(),SYNTAX);
                break;
              }
            }
            break;
          }
          case 9:{//from da
            switch(nToFileType){
              case 5:{//to db
                std::stringstream ssTemp;
                ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
                  <<": conversion from file type \"da\" to file type \"db\" not"
                  <<" yet supported.\n";
                throw exception2(ssTemp.str(),SYNTAX);
                break;
              }
              case 9:{//to da
                std::stringstream ssTemp;
                ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
                  <<": nothing to do. Convert from and to file types the same."
                  <<std::endl;
                throw exception2(ssTemp.str(),SYNTAX);
                break;
              }
              case 6:{//to cb
                std::stringstream ssTemp;
                ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
                  <<": conversion from file type \"da\" to file type \"cb\" not"
                  <<" yet supported.\n";
                throw exception2(ssTemp.str(),SYNTAX);
                break;
              }
              case 10:{//to ca
                std::stringstream ssTemp;
                ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
                  <<": conversion from file type \"da\" to file type \"ca\" not"
                  <<" yet supported.\n";
                throw exception2(ssTemp.str(),SYNTAX);
                break;
              }
              default:{
                std::stringstream ssTemp;
                ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
                  <<": unknown file type to convert to. \n";
                throw exception2(ssTemp.str(),SYNTAX);
                break;
              }
            }
            break;
          }
          case 6:{//from cb
            switch(nToFileType){
              case 5:{//to db
                std::stringstream ssTemp;
                ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
                  <<": conversion from file type \"cb\" to file type \"db\" not"
                  <<" yet supported.\n";
                throw exception2(ssTemp.str(),SYNTAX);
                break;
              }
              case 9:{//to da
                std::stringstream ssTemp;
                ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
                  <<": conversion from file type \"cb\" to file type \"da\" not"
                  <<" yet supported.\n";
                throw exception2(ssTemp.str(),SYNTAX);
                break;
              }
              case 6:{//to cb
                std::stringstream ssTemp;
                ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
                  <<": nothing to do. Convert from and to file types the same."
                  <<"\n";
                throw exception2(ssTemp.str(),SYNTAX);
                break;
              }
              case 10:{//to ca
                convertCollBinToAscii(sFileName);
                break;
              }
              default:{
                std::stringstream ssTemp;
                ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
                  <<": unknown file type to convert to. \n";
                throw exception2(ssTemp.str(),SYNTAX);
                break;
              }
            }
            break;
          }
          case 10:{//from ca
            switch(nToFileType){
              case 5:{//to db
                std::stringstream ssTemp;
                ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
                  <<": conversion from file type \"ca\" to file type \"db\" not"
                  <<" yet supported.\n";
                throw exception2(ssTemp.str(),SYNTAX);
                break;
              }
              case 9:{//to da
                std::stringstream ssTemp;
                ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
                  <<": conversion from file type \"ca\" to file type \"da\" not"
                  <<" yet supported.\n";
                throw exception2(ssTemp.str(),SYNTAX);
                break;
              }
              case 6:{//to cb
                convertCollAsciiToBin(sFileName);
                break;
              }
              case 10:{//to ca
                std::stringstream ssTemp;
                ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": nothing"
                  <<" to do. Convert from and to file types the same.\n";
                throw exception2(ssTemp.str(),SYNTAX);
                break;
              }
              default:{
                std::stringstream ssTemp;
                ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
                  <<": unknown file type to convert to. \n";
                throw exception2(ssTemp.str(),SYNTAX);
              }
            }
            break;
          }
          default:{
            std::stringstream ssTemp;
            ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
              <<": unknown file type to convert from. \n";
            throw exception2(ssTemp.str(),SYNTAX);
            break;
          }
        }
        break;
      }
      case 2:{//make a horizontally averaged profile of quantities
        switch(nFromFileType){
          case 5:{//from db
          
            //convert to a collected ascii file
            combineBinFiles(sFileName);
            makeRadialProFromColBin(sFileName);
            break;
          }
          case 9:{//from da
            std::stringstream ssTemp;
            ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
              <<": averaged profile from file type \"da\" not yet supported\n";
            throw exception2(ssTemp.str(),SYNTAX);
            break;
          }
          case 6:{//from cb
            makeRadialProFromColBin(sFileName);
            break;
          }
          case 10:{//from ca
            convertCollAsciiToBin(sFileName);
            makeRadialProFromColBin(sFileName);
            break;
          }
          default:{
            std::stringstream ssTemp;
            ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
              <<": unknown file type to convert from. \n";
            throw exception2(ssTemp.str(),SYNTAX);
            break;
          }
        }
        break;
      }
      case 3:{//make a 2D slice
        switch(nFromFileType){
          case 5:{//from db
          
            //convert to a collected ascii file
            combineBinFiles(sFileName);
            make2DSlice(sFileName,nPlane,nPlaneIndex);
            break;
          }
          case 9:{//from da
            std::stringstream ssTemp;
            ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
              <<": averaged profile from file type \"da\" not yet supported\n";
            throw exception2(ssTemp.str(),SYNTAX);
            break;
          }
          case 6:{//from cb
            make2DSlice(sFileName,nPlane,nPlaneIndex);
            break;
          }
          case 10:{//from ca
            convertCollAsciiToBin(sFileName);
            make2DSlice(sFileName,nPlane,nPlaneIndex);
            break;
          }
          default:{
            std::stringstream ssTemp;
            ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
              <<": unknown file type to convert from. \n";
            throw exception2(ssTemp.str(),SYNTAX);
            break;
          }
        }
        break;
      }
      case 4:{//compute fourier transform
        std::stringstream ssOutFileName;
        ssOutFileName<<sFileName.substr(0,sFileName.length()-4)<<"-FT.txt";
        computeFourierTrans(sFileName,ssOutFileName.str());
        break;
      }
      case 5:{//convert to LNA format
        switch(nFromFileType){
          case 5:{//from db
          
            //convert to a collected ascii file
            combineBinFiles(sFileName);
            convertBinToLNA(sFileName);
            break;
          }
          case 9:{//from da
            std::stringstream ssTemp;
            ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
              <<": lna file from file type \"da\" not yet supported\n";
            throw exception2(ssTemp.str(),SYNTAX);
            break;
          }
          case 6:{//from cb
            convertBinToLNA(sFileName);
            break;
          }
          case 10:{//from ca
            convertCollAsciiToBin(sFileName);
            convertBinToLNA(sFileName);
            break;
          }
          default:{
            std::stringstream ssTemp;
            ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
              <<": unknown file type to convert from. \n";
            throw exception2(ssTemp.str(),SYNTAX);
            break;
          }
        }
        break;
      }
      case 41:{//compute a fourier transform
        std::stringstream ssOutFileName;
        ssOutFileName<<sFileName.substr(0,sFileName.length()-4)<<"-FT.txt";
        computeFourierTransFromList(sFileName,ssOutFileName.str());
        break;
      }
      default:{
        std::stringstream ssTemp;
        ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
          <<": no operation specified, or an unsuported operation has been"
          <<" requested. The current operation code is "<<nOperation<<"\n";
        throw exception2(ssTemp.str(),SYNTAX);
      }
    }
  }
  catch(exception2& eTemp){
    std::cout<<eTemp.getMsg();
    return -1;
  }
  catch(...){
    std::cout<<"main: unknown error\n";
    return -1;
  }
  return 0;
}
void printHelp(){
  /**\todo need to updated, and revise help text to better describe the program. Some imporovements
    could include:
    -better describing the "-x" appended to the file name base
    -mention that some times it expects a file name base, while others it wants the full file name
    -mention file extensions and naming of output files i.e. what the outputfile for the radially
     averaged profile will be called
    -perhaps mention some of the additional scripts used to extend the functionallity of SPHERLSanal
    */
  std::cout
    <<"syntax: hydroanal [ [flag] [parameter] ] [filename base]\n"
    <<"[flag]          a characters following \"-\" character\n"
    <<"[parameter]     characters following a flag\n"
    <<"[filename base] base file name to convert, -x will be appended to\n"
    <<"                the [basefile name] for all files which match in pwd\n"
    <<"                ,where x is an integer\n"
    <<std::endl
    <<"[flag] [parameter] [discription]\n"
    <<" -c [convert from][convert to] where [convert from] or\n"
    <<"    [convert to] can be one of:\n"
    <<"    db distributed binary\n"
    <<"    da distributed ascii\n"
    <<"    ca collected ascii\n"
    <<"    cb collected binary\n"
    <<" -p    sets persicion of ASCII output, default is 15 decimal places\n"
    <<" -f s  sets output formating to scientific\n"
    <<"    f  sets output formating to fixed\n"
    <<"       defult is scientific (s)\n"
    <<" -h    displays this message\n"
    <<" -a [input file type]   make a radial profile from [input file type]\n"
    <<" -s [input file type] [plane] [planeIndex]   make a 2D slice where\n"
    <<"       [input file type] is a two character combination of c/d or b/a for\n"
    <<"       collected/distributed and binary/ascii.\n"
    <<"       [plane] is either 0,1,2 for a r-theta, theta-phi, or r-phi\n"
    <<"       plane respectively. [planeIndex] is the index of the slice in the\n"
    <<"       direction perpendicular to the plane.\n"
    <<" -t [input file] calculates the fourier transform on [input file] of the \n"
    <<"       radial velocity at i+1/2.\n"
    <<"       [input file] is expected to be a watchZone file. Output is sent to \n"
    <<"       to an output file called [input file without exetension]-FT.txt\n"
    <<" -tl [input file] calculates the fourier transform on [input file]. The \n"
    <<"       expected format is two columns, the first being time, the second being\n"
    <<"       the periodic quantity. the output file will then have a -FT appened to the file name.\n"
    <<" -l [input file type] [input file] converts a model into the formate used\n"
    <<"       by LNA.\n";
}
void convertCollBinToAscii(std::string sFileName){//tested
  
  //open input file
  if(sFileName.size()==0){
    std::stringstream ssTemp;
    ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
      <<":no input file specified\n";
    throw exception2(ssTemp.str(),INPUT);
  }
  std::ifstream ifFile;
  ifFile.open(sFileName.c_str(),std::ios::binary);
  if(!ifFile.good()){
    std::stringstream ssTemp;
    ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": input file \""
      <<sFileName<<"\" didn't open properly\n";
    throw exception2(ssTemp.str(),INPUT);
  }
  
  //check that it is a binary file
  char cTemp;
  ifFile.read((char*)(&cTemp),sizeof(char));
  if(cTemp!='b'){
    std::stringstream ssTemp;
    ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": input file \""
      <<sFileName<<"\" isn't a binary file.\n";
    throw exception2(ssTemp.str(),INPUT);
  }
  
  //check that it is the correct version
  int nTemp;
  ifFile.read((char*)(&nTemp),sizeof(int));
  if(nTemp!=nDumpFileVersion){
    std::stringstream ssTemp;
    ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": inpput file \""
      <<sFileName<<"\" version \""<<nTemp
      <<"\" isn't the supported version \""<<nDumpFileVersion<<"\".\n";
    throw exception2(ssTemp.str(),INPUT);
  }
  
  //open output file
  std::string sFileNameOut=sFileName+".txt";
  std::ofstream ofFile;
  ofFile.open(sFileNameOut.c_str());
  if(!ofFile.good()){
    std::stringstream ssTemp;
    ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": output file \""
      <<sFileNameOut<<" didn't open properly\n";
    throw exception2(ssTemp.str(),INPUT);
  }
  
  //read in binary input file and write out in ascii
  //write out that the file is an ascii file
  ofFile<<'a'<<" ";
  
  //write out version
  ofFile<<nTemp<<std::endl;
  
  //set double output precision
  ofFile.precision(nPrecisionAscii);
  if(bScientific){
    ofFile.unsetf(std::ios::fixed);
    ofFile.setf(std::ios::scientific);
  }
  else{
    ofFile.unsetf(std::ios::scientific);
    ofFile.setf(std::ios::fixed);
  }
  
  //read in time
  double dTime;
  ifFile.read((char*)(&dTime),sizeof(double));
  ofFile<<dTime<<" ";
  
  //read in time step index
  int nTimeStepIndex;
  ifFile.read((char*)(&nTimeStepIndex),sizeof(int));
  ofFile<<nTimeStepIndex<<std::endl;
  
  //read in last timestep1
  double dTimeStep1;
  ifFile.read((char*)(&dTimeStep1),sizeof(double));
  ofFile<<dTimeStep1<<std::endl;
  
  //read in last timestep2
  double dTimeStep2;
  ifFile.read((char*)(&dTimeStep2),sizeof(double));
  ofFile<<dTimeStep2<<std::endl;
  
  //read in alpha
  double dAlpha;
  ifFile.read((char*)(&dAlpha),sizeof(double));
  ofFile<<dAlpha<<std::endl;
  
  //read in equation of state info
  int nGammaLaw;
  ifFile.read((char*)(&nGammaLaw),sizeof(int));
  ofFile<<nGammaLaw<<" ";
  if(nGammaLaw==0){
    double dGamma;
    ifFile.read((char*)(&dGamma),sizeof(double));
    
    ofFile<<dGamma<<std::endl;
  }
  else{
    char *cBuffer=new char[nGammaLaw+1];
    ifFile.read(cBuffer,nGammaLaw*sizeof(char));
    cBuffer[nGammaLaw]='\0';
    std::string sEOSTable;
    sEOSTable=cBuffer;
    ofFile<<sEOSTable<<std::endl;
    delete [] cBuffer;
  }
  
  //read in/write out artificial viscosity
  double dAV;
  ifFile.read((char*)(&dAV),sizeof(double));
  ofFile<<dAV<<std::endl;
  
  //read in/write out artificial viscosity threshold
  double dAVThreshold;
  ifFile.read((char*)(&dAVThreshold),sizeof(double));
  ofFile<<dAVThreshold<<std::endl;
  
  //read in global grid size
  int nSizeGlobe[3];
  ifFile.read((char*)(nSizeGlobe),3*sizeof(int));
  ofFile<<nSizeGlobe[0]<<" ";
  ofFile<<nSizeGlobe[1]<<" ";
  ofFile<<nSizeGlobe[2]<<std::endl;
  
  //read in periodicity
  int nPeriodic[3];
  ifFile.read((char*)(nPeriodic),3*sizeof(int));
  ofFile<<nPeriodic[0]<<" ";
  ofFile<<nPeriodic[1]<<" ";
  ofFile<<nPeriodic[2]<<std::endl;
  
  //read in number of 1D Zones
  int nNum1DZones;
  ifFile.read((char*)(&nNum1DZones),sizeof(int));
  ofFile<<nNum1DZones<<std::endl;
  
  //read in number of ghostcells
  int nNumGhostCells;
  ifFile.read((char*)(&nNumGhostCells),sizeof(int));
  ofFile<<nNumGhostCells<<std::endl;
  
  //read in number of grid variables
  int nNumVars;
  ifFile.read((char*)(&nNumVars),sizeof(int));
  ofFile<<nNumVars<<std::endl;
  
  //get variable info, and set grid sizes
  int **nSize=new int*[nNumVars];
  int **nVarInfo=new int*[nNumVars];
  for(int n=0;n<nNumVars;n++){
    nSize[n]=new int[3];
    nVarInfo[n]=new int[4];
    ifFile.read((char*)(nVarInfo[n]),(4)*sizeof(int));
    for(int l=0;l<3;l++){
      ofFile<<nVarInfo[n][l]<<" ";
      if(nVarInfo[n][l]==-1){//variable not defined in direction l
        nSize[n][l]=1;
      }
      else if(nVarInfo[n][l]==1&&nPeriodic[l]==0){//interface variable
        nSize[n][l]=nSizeGlobe[l]+1;
      }
      else{
        nSize[n][l]=nSizeGlobe[l];
      }
    }
    ofFile<<nVarInfo[n][3]<<" ";
    ofFile<<" ";
  }
  ofFile<<std::endl;
  
  //write out the grid
  for(int n=0;n<nNumVars;n++){
    int nGhostCellsX=1;
    if(nVarInfo[n][0]==-1){
      nGhostCellsX=0;
    }
    int nGhostCellsY=1;
    if(nVarInfo[n][1]==-1){
      nGhostCellsY=0;
    }
    int nGhostCellsZ=1;
    if(nVarInfo[n][2]==-1){
      nGhostCellsZ=0;
    }
    //write out 1D part of the grid
    int nSizeX=nGhostCellsX*(nNum1DZones+nNumGhostCells);/*may be need to +1 if only one proc 
      and variable in interface centered*/
    if (nVarInfo[n][0]==1&&nPeriodic[0]==0){
      nSizeX=nGhostCellsX*(nNum1DZones+1+nNumGhostCells);
    }
    int nSizeY=1;
    int nSizeZ=1;
    for(int i=0;i<nSizeX;i++){
      for(int j=0;j<nSizeY;j++){
        double *dRow=new double[nSizeZ];
        ifFile.read((char*)(dRow),nSizeZ*sizeof(double));
        for(int k=0;k<nSizeZ;k++){
          ofFile<<dRow[k]<<" ";
        }
        ofFile<<std::endl;//new line for each new Y
        delete [] dRow;
      }
      ofFile<<std::endl;//skip a line for each new X
    }
    
    //write out the rest of the grid
    nSizeX=nSize[n][0]+nGhostCellsX*(nNumGhostCells-nNum1DZones);
    if(nVarInfo[n][0]==1&&nPeriodic[0]==0){
      nSizeX=nSize[n][0]+nGhostCellsX*(nNumGhostCells-(nNum1DZones+1));
    }
    nSizeY=nSize[n][1]+nGhostCellsY*2*nNumGhostCells;
    nSizeZ=nSize[n][2]+nGhostCellsZ*2*nNumGhostCells;
    double *dTempArray=new double[nSizeZ];
    for(int i=0;i<nSizeX;i++){
      for(int j=0;j<nSizeY;j++){
        if(ifFile.eof()){
          std::stringstream ssTemp;
          ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
            <<": reached end of file sooner than expected\n";
          throw exception2(ssTemp.str(),INPUT);
        }
        ifFile.read((char*)(dTempArray),(nSizeZ)*sizeof(double));
        for(int k=0;k<nSizeZ;k++){
          ofFile<<dTempArray[k]<<" ";
        }
        ofFile<<std::endl;//new line for each new Y
      }
      ofFile<<std::endl;//skip a line for each new X
    }
    ofFile<<std::endl;//skip two lines for each new variable
    delete [] dTempArray;
    
  }
  ifFile.close();
  ofFile.close();
  for(int n=0;n<nNumVars;n++){
    delete [] nSize[n];
    delete [] nVarInfo[n];
  }
  delete [] nSize;
  delete [] nVarInfo;
}
void convertDistBinToAscii(std::string sFileNameBase){//tested
  
  //open input file
  if(sFileNameBase.size()==0){
    std::stringstream ssTemp;
    ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
      <<": no input file specified\n";
    throw exception2(ssTemp.str(),INPUT);
  }
  
  //find out how many files that start with filename are present
  std::stringstream ssFileName;
  int nNumFiles=0;
  ssFileName<<sFileNameBase<<"-"<<nNumFiles;
  //int nDimX,nDimY,nDimZ;
  
  //first file is handled differently
  std::ifstream ifFile;
  ifFile.open(ssFileName.str().c_str(),std::ios::binary);
  if(!ifFile.good()){
    std::stringstream ssTemp;
    ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": input file \""
      <<ssFileName.str()<<"\" didn't open properly\n";
    throw exception2(ssTemp.str(),INPUT);
  }
  
  //check file type
  char cTemp;
  ifFile.read((char*)(&cTemp),sizeof(char));
  if(cTemp!='b'){
    std::stringstream ssTemp;
    ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": file \""
      <<ssFileName.str()<<"\" not a binary file\n";
    throw exception2(ssTemp.str(),INPUT);
  }
  
  //check file version
  int nTemp;
  ifFile.read((char*)(&nTemp),sizeof(int));
  if(nTemp!=nDumpFileVersion){
    std::stringstream ssTemp;
    ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": file \""
      <<ssFileName.str()<<"\" version \""<<nTemp
      <<"\" not the same as supported version \""<<nDumpFileVersion<<"\"\n";
    throw exception2(ssTemp.str(),INPUT);
  }
  
  //open output file
  std::stringstream ssFileNameOut;
  ssFileNameOut<<sFileNameBase<<"-"<<0<<".txt";
  std::ofstream ofFile;
  ofFile.open(ssFileNameOut.str().c_str());
  if(!ofFile.good()){
    std::stringstream ssTemp;
    ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": output file "
      <<ssFileNameOut.str()<<" didn't open properly\n";
    throw exception2(ssTemp.str(),INPUT);
  }
  
  //read in binary input file and write out in ascii
  //write out file type, and version
  ofFile<<'a'<<" "<<nTemp<<std::endl;
  
  //set double output precision
  if(bScientific){
    ofFile.unsetf(std::ios::fixed);
    ofFile.setf(std::ios::scientific);
  }
  else{
    ofFile.unsetf(std::ios::scientific);
    ofFile.setf(std::ios::fixed);
  }
  ofFile.precision(nPrecisionAscii);
  
  //read in/write out time
  double dTime;
  ifFile.read((char*)(&dTime),sizeof(double));
  ofFile<<dTime<<" ";
  
  //read in/write out time step index
  int  nTimeStep;
  ifFile.read((char*)(&nTimeStep),sizeof(int));
  ofFile<<nTimeStep<<std::endl;
  
  //read in/write out timestep
  double dTimeStep1;
  ifFile.read((char*)(&dTimeStep1),sizeof(double));
  ofFile<<dTimeStep1<<std::endl;
  
  //read in/write out timestep
  double dTimeStep2;
  ifFile.read((char*)(&dTimeStep2),sizeof(double));
  ofFile<<dTimeStep2<<std::endl;
  
  //read in/write out alpha
  double dAlpha;
  ifFile.read((char*)(&dAlpha),sizeof(double));
  ofFile<<dAlpha<<std::endl;
  
  //read in equation of state info
  int nGammaLaw;
  ifFile.read((char*)(&nGammaLaw),sizeof(int));
  ofFile<<nGammaLaw<<" ";
  std::string sEOSTable;
  double dGamma=0;
  if(nGammaLaw==0){
    ifFile.read((char*)(&dGamma),sizeof(double));
    
    ofFile<<dGamma<<std::endl;
  }
  else{
    char *cBuffer=new char[nGammaLaw+1];
    ifFile.read(cBuffer,nGammaLaw*sizeof(char));
    cBuffer[nGammaLaw]='\0';
    sEOSTable=cBuffer;
    ofFile<<sEOSTable<<std::endl;
    delete [] cBuffer;
  }
  
  //write out artificial viscosity
  double dA;
  ifFile.read((char*)(&dA),sizeof(double));
  ofFile<<dA<<std::endl;
  
  //write out artificial viscosity threshold
  double dAVThreshold;
  ifFile.read((char*)(&dAVThreshold),sizeof(double));
  ofFile<<dAVThreshold<<std::endl;
  
  //read in processor dimensions
  int nProcDimX,nProcDimY,nProcDimZ;
  ifFile.read((char*)(&nProcDimX),sizeof(int));
  ofFile<<nProcDimX<<" ";
  ifFile.read((char*)(&nProcDimY),sizeof(int));
  ofFile<<nProcDimY<<" ";
  ifFile.read((char*)(&nProcDimZ),sizeof(int));
  ofFile<<nProcDimZ<<std::endl;
  
  //read in processor coordinates
  ifFile.read((char*)(&nTemp),sizeof(int));
  ofFile<<nTemp<<" ";
  ifFile.read((char*)(&nTemp),sizeof(int));
  ofFile<<nTemp<<" ";
  ifFile.read((char*)(&nTemp),sizeof(int));
  ofFile<<nTemp<<std::endl;
  
  //read in periodicity
  int nPeriodic[3];
  ifFile.read((char*)(nPeriodic),3*sizeof(int));
  ofFile<<nPeriodic[0]<<" "<<nPeriodic[1]<<" "<<nPeriodic[2]<<std::endl;
  
  //read in number of variables
  int nNumVars;
  ifFile.read((char*)(&nNumVars),sizeof(int));
  ofFile<<nNumVars<<std::endl;
  
  //read in variable info
  int **nVariables=new int*[nNumVars];
  for(int i=0;i<nNumVars;i++){
    nVariables[i]=new int[3];
    ifFile.read((char*)(nVariables[i]),4*sizeof(int));
    ofFile<<nVariables[i][0]<<" ";
    ofFile<<nVariables[i][1]<<" ";
    ofFile<<nVariables[i][2]<<" ";
    ofFile<<nVariables[i][3]<<"  ";
  }
  ofFile<<std::endl;
  
  //read in number of 1D zones
  ifFile.read((char*)(&nTemp),sizeof(int));
  ofFile<<nTemp<<std::endl;
  
  //read in global grid size
  int nGlobalX, nGlobalY, nGlobalZ;
  ifFile.read((char*)(&nGlobalX),sizeof(int));
  ofFile<<nGlobalX<<" ";
  ifFile.read((char*)(&nGlobalY),sizeof(int));
  ofFile<<nGlobalY<<" ";
  ifFile.read((char*)(&nGlobalZ),sizeof(int));
  ofFile<<nGlobalZ<<std::endl;
  
  //read in local grid size
  int **nSize=new int*[nNumVars];
  for(int i=0;i<nNumVars;i++){
    nSize[i]=new int[3];
    ifFile.read((char*)(nSize[i]),3*sizeof(int));
    ofFile<<nSize[i][0]<<" ";
    ofFile<<nSize[i][1]<<" ";
    ofFile<<nSize[i][2]<<"  ";
  }
  ofFile<<std::endl;
  
  //read in number of ghostcells
  int nNumGhostCells;
  ifFile.read((char*)(&nNumGhostCells),sizeof(int));
  ofFile<<nNumGhostCells<<std::endl;

  double dTemp;
  for(int n=0;n<nNumVars;n++){
    
    //read in/write out inner grid
    //double *dTempArray=new double[nSize[n][2]];
    
    int nGhostCellsX=1;
    if(nVariables[n][0]==-1){
      nGhostCellsX=0;
    }
    for(int i=0;i<nSize[n][0]+nGhostCellsX*nNumGhostCells;i++){
      for(int j=0;j<nSize[n][1];j++){
        if(ifFile.eof()){
          std::stringstream ssTemp;
          ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
            <<": reached end of file sooner than expected\n";
          throw exception2(ssTemp.str(),INPUT);
        }
        for(int k=0;k<nSize[n][2];k++){
          ifFile.read((char*)(&dTemp),sizeof(double));
          ofFile<<dTemp<<" ";
        }
        ofFile<<std::endl;//new line for each new Y
      }
      ofFile<<std::endl;//skip a line for each new X
    }
    
    //read in/write out outer grid
    int nSizeY=nGlobalY;
    int nSizeZ=nGlobalZ;
    if(nVariables[n][1]==-1){
      nSizeY=nProcDimY;
    }
    if(nVariables[n][2]==-1){
      nSizeZ=nProcDimZ;
    }
    
    //dTempArray=new double[nGlobalZ+nVariables[n][2]];
    double *dTempArray=new double[nSizeZ];
    for(int i=nSize[n][0]+nGhostCellsX*nNumGhostCells;
      i<nSize[n][0]+nGhostCellsX*2*nNumGhostCells;i++){
      for(int j=0;j<nSizeY;j++){
        if(ifFile.eof()){
          std::stringstream ssTemp;
          ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
            <<": reached end of file sooner than expected\n";
          throw exception2(ssTemp.str(),INPUT);
        }
        ifFile.read((char*)(dTempArray),nSizeZ*sizeof(double));
        for(int k=0;k<nSizeZ;k++){
          ofFile<<dTempArray[k]<<" ";
        }
        ofFile<<std::endl;//new line for each new Y
      }
      ofFile<<std::endl;//skip a line for each new X
    }
    ofFile<<std::endl;//skip two lines for each new variable
    delete [] dTempArray;
  }
  
  //delete memory for nVariables
  for(int i=0;i<nNumVars;i++){
    delete [] nVariables[i];
  }
  delete [] nVariables;
  
  //delete memory for nSize
  for(int i=0;i<nNumVars;i++){
    delete [] nSize[i];
  }
  delete [] nSize;
  
  ifFile.close();
  ofFile.close();
  
  nNumFiles++;
  ssFileName.str("");//reset stream
  ssFileName<<sFileNameBase<<"-"<<nNumFiles;
  
  //handle the rest of the files
  while(bFileExists(ssFileName.str())){
    
    //open input file
    std::ifstream ifFile;
    ifFile.open(ssFileName.str().c_str(),std::ios::binary);
    if(!ifFile.good()){
      std::stringstream ssTemp;
      ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": input file "
        <<ssFileName.str()<<" didn't open properly\n";
      throw exception2(ssTemp.str(),INPUT);
    }
    
    //check file type
    char cTemp;
    ifFile.read((char*)(&cTemp),sizeof(char));
    if(cTemp!='b'){
      std::stringstream ssTemp;
      ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": file \""
        <<ssFileName.str()<<"\" not a binary file\n";
      throw exception2(ssTemp.str(),INPUT);
    }
    
    //check file version
    int nTemp;
    ifFile.read((char*)(&nTemp),sizeof(int));
    if(nTemp!=nDumpFileVersion){
      std::stringstream ssTemp;
      ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": file \""
        <<ssFileName.str()<<"\" version \""<<nTemp
        <<"\" not the same version as supported version \""<<nDumpFileVersion<<"\"\n";
      throw exception2(ssTemp.str(),INPUT);
    }
    
    //check time
    double dTemp;
    ifFile.read((char*)(&dTemp),sizeof(double));
    if(dTemp!=dTime){
      std::stringstream ssTemp;
      ssTemp.unsetf(std::ios::fixed);
      ssTemp.setf(std::ios::scientific);
      ssTemp.precision(15);
      ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": input file \""<<ssFileName.str()
        <<"\" has a different time="<<dTemp<<" than \""<<sFileNameBase<<"-0 of "<<dTime<<std::endl;
      throw exception2(ssTemp.str(),INPUT);
    }
    
    //check time step index
    ifFile.read((char*)(&nTemp),sizeof(int));
    if(nTemp!=nTimeStep){
      std::stringstream ssTemp;
      ssTemp.unsetf(std::ios::fixed);
      ssTemp.setf(std::ios::scientific);
      ssTemp.precision(15);
      ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": input file \""<<ssFileName.str()
        <<"\" has a different time step index="<<nTemp<<" than \""<<sFileNameBase<<"-0 of "<<nTimeStep
        <<std::endl;
      throw exception2(ssTemp.str(),INPUT);
    }
    
    //check time step
    ifFile.read((char*)(&dTemp),sizeof(double));
    if(dTemp!=dTimeStep1){
      std::stringstream ssTemp;
      ssTemp.unsetf(std::ios::fixed);
      ssTemp.setf(std::ios::scientific);
      ssTemp.precision(15);
      ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": input file \""<<ssFileName.str()
        <<"\" has a different time step="<<dTemp<<" than \""<<sFileNameBase<<"-0 of "<<dTimeStep1
        <<std::endl;
      throw exception2(ssTemp.str(),INPUT);
    }
    
    //check time step
    ifFile.read((char*)(&dTemp),sizeof(double));
    if(dTemp!=dTimeStep2){
      std::stringstream ssTemp;
      ssTemp.unsetf(std::ios::fixed);
      ssTemp.setf(std::ios::scientific);
      ssTemp.precision(15);
      ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": input file \""<<ssFileName.str()
        <<"\" has a different time step="<<dTemp<<" than \""<<sFileNameBase<<"-0 of "<<dTimeStep2
        <<std::endl;
      throw exception2(ssTemp.str(),INPUT);
    }
    
    //check alpha
    ifFile.read((char*)(&dTemp),sizeof(double));
    if(dTemp!=dAlpha){
      std::stringstream ssTemp;
      ssTemp.unsetf(std::ios::fixed);
      ssTemp.setf(std::ios::scientific);
      ssTemp.precision(15);
      ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": input file \""<<ssFileName.str()
        <<"\" has a different alpha="<<dTemp<<" than \""<<sFileNameBase<<"-0 of "<<dAlpha
        <<std::endl;
      throw exception2(ssTemp.str(),INPUT);
    }
    
    //check EOS Info
    ifFile.read((char*)(&nTemp),sizeof(int));
    if(nTemp!=nGammaLaw){
      std::stringstream ssTemp;
      ssTemp.unsetf(std::ios::fixed);
      ssTemp.setf(std::ios::scientific);
      ssTemp.precision(15);
      ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": input file \""<<ssFileName.str()
        <<"\" has a different equation of state file name length="<<nTemp<<" than \""<<sFileNameBase
        <<"-0 of "<<nGammaLaw<<std::endl;
      throw exception2(ssTemp.str(),INPUT);
    }
    if(nGammaLaw==0){
      ifFile.read((char*)(&dTemp),sizeof(double));
      
      if(dTemp!=dGamma){
        std::stringstream ssTemp;
        ssTemp.unsetf(std::ios::fixed);
        ssTemp.setf(std::ios::scientific);
        ssTemp.precision(15);
        ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": input file \""<<ssFileName.str()
          <<"\" has a different adiabatic gamma="<<dTemp<<" than \""<<sFileNameBase
          <<"-0 of "<<dGamma<<std::endl;
        throw exception2(ssTemp.str(),INPUT);
      }
    }
    else{
      char *cBuffer=new char[nGammaLaw+1];
      ifFile.read(cBuffer,nGammaLaw*sizeof(char));
      cBuffer[nGammaLaw]='\0';
      std::string sTemp;
      sTemp=cBuffer;
      if(sEOSTable.compare(sTemp)!=0){
        std::stringstream ssTemp;
        ssTemp.unsetf(std::ios::fixed);
        ssTemp.setf(std::ios::scientific);
        ssTemp.precision(15);
        ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": input file \""<<ssFileName.str()
          <<"\" has a different equation of state file =\""<<sTemp<<"\" than \""<<sFileNameBase
          <<"-0 of \""<<sEOSTable<<"\"\n";
        throw exception2(ssTemp.str(),INPUT);
      }
      delete [] cBuffer;
    }
    
    //write out artificial viscosity
    ifFile.read((char*)(&dTemp),sizeof(double));
    if(dTemp!=dA){
      std::stringstream ssTemp;
      ssTemp.unsetf(std::ios::fixed);
      ssTemp.setf(std::ios::scientific);
      ssTemp.precision(15);
      ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": input file \""<<ssFileName.str()
        <<"\" has a different artificial viscosity="<<dTemp<<" than \""<<sFileNameBase
        <<"-0 of "<<dA<<std::endl;
      throw exception2(ssTemp.str(),INPUT);
    }
    
    //write out artificial viscosity threshold
    ifFile.read((char*)(&dTemp),sizeof(double));
    if(dTemp!=dAVThreshold){
      std::stringstream ssTemp;
      ssTemp.unsetf(std::ios::fixed);
      ssTemp.setf(std::ios::scientific);
      ssTemp.precision(15);
      ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": input file \""<<ssFileName.str()
        <<"\" has a different artificial viscosity threshold="<<dTemp<<" than \""<<sFileNameBase
        <<"-0 of "<<dAVThreshold<<std::endl;
      throw exception2(ssTemp.str(),INPUT);
    }
    
    //set integer precision to zero
    ofFile.precision(0);
    ofFile.setf(std::ios::fixed);
    
    //open output file
    std::string sFileName=ssFileName.str();
    sFileName+=".txt";
    std::ofstream ofFile;
    ofFile.open(sFileName.c_str());
    if(!ofFile.good()){
      std::stringstream ssTemp;
      ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": output file "
        <<sFileName<<" didn't open properly\n";
      throw exception2(ssTemp.str(),INPUT);
    }
    
    //read in binary input file and write out in ascii
    //write out file type and version
    ofFile<<'a'<<" "<<nDumpFileVersion<<std::endl;
    
    //write out time
    if(bScientific){
      ofFile.unsetf(std::ios::fixed);
      ofFile.setf(std::ios::scientific);
    }
    else{
      ofFile.unsetf(std::ios::scientific);
      ofFile.setf(std::ios::fixed);
    }
    //set double output precision
    ofFile.precision(nPrecisionAscii);
    ofFile<<dTime<<" ";
    
    //output time step
    ofFile<<nTimeStep<<std::endl;
    
    //output AV
    ofFile<<dA<<std::endl;
    
    //output AV Threshold
    ofFile<<dAVThreshold<<std::endl;
    
    //read in processor coordinates
    ifFile.read((char*)(&nTemp),sizeof(int));
    ofFile<<nTemp<<" ";
    ifFile.read((char*)(&nTemp),sizeof(int));
    ofFile<<nTemp<<" ";
    ifFile.read((char*)(&nTemp),sizeof(int));
    ofFile<<nTemp<<std::endl;
    
    //read in number of grid variables
    int nNumVars;
    ifFile.read((char*)(&nNumVars),sizeof(int));
    ofFile<<nNumVars<<std::endl;
    
    //read in variable info 
    int **nVariables=new int*[nNumVars];
    for(int i=0;i<nNumVars;i++){
      nVariables[i]=new int[3];
      ifFile.read((char*)(nVariables[i]),4*sizeof(int));
      ofFile<<nVariables[i][0]<<" ";
      ofFile<<nVariables[i][1]<<" ";
      ofFile<<nVariables[i][2]<<" ";
      ofFile<<nVariables[i][3]<<"  ";
    }
    ofFile<<std::endl;
    
    //read in local grid size
    int **nSize=new int*[nNumVars];
    for(int i=0;i<nNumVars;i++){
      nSize[i]=new int[3];
      ifFile.read((char*)(nSize[i]),3*sizeof(int));
      ofFile<<nSize[i][0]<<" ";
      ofFile<<nSize[i][1]<<" ";
      ofFile<<nSize[i][2]<<"  ";
    }
    ofFile<<std::endl;
    
    //read in number of ghostcells
    int nNumGhostCells;
    ifFile.read((char*)(&nNumGhostCells),sizeof(int));
    ofFile<<nNumGhostCells<<std::endl;
    
    //set double output precision
    if(bScientific){
      ofFile.unsetf(std::ios::fixed);
      ofFile.setf(std::ios::scientific);
    }
    else{
      ofFile.unsetf(std::ios::scientific);
      ofFile.setf(std::ios::fixed);
    }
    ofFile.precision(nPrecisionAscii);
    
    //read in the grid
    for(int n=0;n<nNumVars;n++){
      int nSizeX=nSize[n][0];
      int nSizeY=nSize[n][1];
      int nSizeZ=nSize[n][2];
      if(nVariables[n][0]!=-1){
        nSizeX+=2*nNumGhostCells;
      }
      if(nVariables[n][1]!=-1){
        nSizeY+=2*nNumGhostCells;
      }
      if(nVariables[n][2]!=-1){
        nSizeZ+=2*nNumGhostCells;
      }
      double *dTempArray=new double[nSizeZ];
      for(int i=0;i<nSizeX;i++){
        for(int j=0;j<nSizeY;j++){
          if(ifFile.eof()){
            std::stringstream ssTemp;
            ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
              <<": reached end of file sooner than expected\n";
            throw exception2(ssTemp.str(),INPUT);
          }
          ifFile.read((char*)(dTempArray),nSizeZ*sizeof(double));
          for(int k=0;k<nSizeZ;k++){
            ofFile<<dTempArray[k]<<" ";
          }
          ofFile<<std::endl;//new line for each new Y
        }
        ofFile<<std::endl;//skip a line for each new X
      }
      ofFile<<std::endl;//skip two lines for each new variable
      delete [] dTempArray;
    }
    ifFile.close();
    ofFile.close();
    
    nNumFiles++;
    ssFileName.str("");//reset stream
    ssFileName<<sFileNameBase<<"-"<<nNumFiles;
    
    //delete memory for nSize
    for(int i=0;i<nNumVars;i++){
      delete [] nSize[i];
    }
    delete [] nSize;
  }
}
void combineBinFiles(std::string sFileNameBase){//tested
  
  //find  out how many files that start with filename are present
  std::ostringstream ossFileName;
  int nNumFiles=0;
  ossFileName<<sFileNameBase<<"-"<<nNumFiles;
  while(bFileExists(ossFileName.str())){
    nNumFiles++;
    ossFileName.str("");//flush stream
    ossFileName<<sFileNameBase<<"-"<<nNumFiles;
  }
  if(nNumFiles==0){
    std::stringstream ssTemp;
    ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
      <<": no files to combine found\n";
    throw exception2(ssTemp.str(),INPUT);
  }
  int ***nFileGridSizes=new int**[nNumFiles];
  int **nFileProcCoords=new int*[nNumFiles];
  std::ifstream *ifIn=new std::ifstream[nNumFiles];
  int nGlobalGridDims[3]={0,0,0};
  int nGlobalProcDims[3]={0,0,0};
  int ***nVariableInfo=new int**[nNumFiles];
  int nNumGhostCells;
  int nNumVars;
  int nNum1DZones;
  int nPeriodic[3];
  double dTime;
  int nTimeStepIndex;
  double dTimeStep1;
  double dTimeStep2;
  double dAlpha;
  int nGammaLaw;
  double dGamma;
  std::string sEOSFileName;
  double dA;
  double dAVThreshold;
  
  //read file headers and check that they are compatiable with each other
  for(int i=0;i<nNumFiles;i++){
    
    //open file i
    ossFileName.str("");//flush stream
    ossFileName<<sFileNameBase<<"-"<<i;
    ifIn[i].open(ossFileName.str().c_str(),std::ios::binary);
    if(!ifIn[i].good()){
      std::stringstream ssTemp;
      ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
        <<": error opening the file "<<ossFileName.str()<<std::endl;
      throw exception2(ssTemp.str(),INPUT);
    }
    
    //check that file is binary
    char cTemp;
    ifIn[i].read((char*)(&cTemp),sizeof(char));
    if(cTemp!='b'){
      std::stringstream ssTemp;
      ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": file \""
        <<ossFileName.str()<<"\" is not a binary file, aborting!\n";
      throw exception2(ssTemp.str(),INPUT);
    }
    
    //check that file is correct version
    int nTemp;
    ifIn[i].read((char*)(&nTemp),sizeof(int));
    if(nTemp!=1){
      std::stringstream ssTemp;
      ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": file \""
        <<ossFileName.str()<<"\" is version \""<<nTemp
        <<"\", which is not the supported version \""<<nDumpFileVersion<<"\"\n";
      throw exception2(ssTemp.str(),INPUT);
    }
    
    //read in header
    if(i==0){
      
      //read in time
      ifIn[i].read((char*)(&dTime),sizeof(double));
      
      //read in time step index
      ifIn[i].read((char*)(&nTimeStepIndex),sizeof(int));
      
      //read in timestep
      ifIn[i].read((char*)(&dTimeStep1),sizeof(double));
      
      //read in timestep
      ifIn[i].read((char*)(&dTimeStep2),sizeof(double));
      
      //read in alpha
      ifIn[i].read((char*)(&dAlpha),sizeof(double));
      
      //read in nGammaLaw
      ifIn[i].read((char*)(&nGammaLaw),sizeof(int));
      
      if(nGammaLaw==0){
        ifIn[i].read((char*)(&dGamma),sizeof(double));
      }
      else{
        char* cBuffer=new char[nGammaLaw+1];
        ifIn[i].read(cBuffer,nGammaLaw*sizeof(char));
        cBuffer[nGammaLaw]='\0';
        std::string sTemp=cBuffer;
        sEOSFileName=sTemp;
        delete [] cBuffer;
      }
      
      //read in artificial viscosity
      ifIn[i].read((char*)(&dA),sizeof(double));
      
      //read in artificial viscosity threshold
      ifIn[i].read((char*)(&dAVThreshold),sizeof(double));
      
      //read in processor dims
      ifIn[i].read((char*)(nGlobalProcDims),3*sizeof(int));
      
      //read in coordinates
      nFileProcCoords[i]=new int[3];
      ifIn[i].read((char*)(nFileProcCoords[i]),3*sizeof(int));
      
      //read in periodic
      ifIn[i].read((char*)(nPeriodic),3*sizeof(int));
      
      //read in number of variables
      ifIn[i].read((char*)(&nNumVars),sizeof(int));
      
      //read in variable info
      nVariableInfo[i]=new int*[nNumVars];
      for(int n=0;n<nNumVars;n++){
        nVariableInfo[i][n]=new int[4];
        ifIn[i].read((char*)(nVariableInfo[i][n]),4*sizeof(int));
      }
      
      //read in number of 1D zones
      ifIn[i].read((char*)(&nNum1DZones),sizeof(int));
      
      //read in global grid size
      ifIn[i].read((char*)(nGlobalGridDims),3*sizeof(int));
      
      //read in local grid size for each variable
      nFileGridSizes[i]=new int*[nNumVars];
      for(int n=0;n<nNumVars;n++){
        nFileGridSizes[i][n]=new int[3];
        ifIn[i].read((char*)(nFileGridSizes[i][n]),3*sizeof(int));
      }
      
      //read in number of ghostcells
      ifIn[i].read((char*)(&nNumGhostCells),sizeof(int));
    }
    else{
      
      //read in time
      double dTemp;
      ifIn[i].read((char*)(&dTemp),sizeof(double));
      if(dTemp!=dTime){
        std::stringstream ssTemp;
        ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": file \""
          <<ossFileName.str()<<"\" has time="<<dTemp
          <<"which is different from the time in \""<<sFileNameBase<<"-0\" of "<<dTime<<std::endl;
        throw exception2(ssTemp.str(),INPUT);
      }
      
      //read in timestep index
      int nTemp;
      ifIn[i].read((char*)(&nTemp),sizeof(int));
      if(nTemp!=nTimeStepIndex){
        std::stringstream ssTemp;
        ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": file \""
          <<ossFileName.str()<<"\" has time step index="<<nTemp
          <<" which is different from the time step index in \""<<sFileNameBase<<"-0\" of "
          <<nTimeStepIndex<<std::endl;
        throw exception2(ssTemp.str(),INPUT);
      }
      
      //read in timestep
      ifIn[i].read((char*)(&dTemp),sizeof(double));
      if(dTemp!=dTimeStep1){
        std::stringstream ssTemp;
        ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": file \""
          <<ossFileName.str()<<"\" has time step="<<dTemp
          <<" which is different from the time step in \""<<sFileNameBase<<"-0\" of "
          <<dTimeStep1<<std::endl;
        throw exception2(ssTemp.str(),INPUT);
      }
      
      //read in timestep
      ifIn[i].read((char*)(&dTemp),sizeof(double));
      if(dTemp!=dTimeStep2){
        std::stringstream ssTemp;
        ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": file \""
          <<ossFileName.str()<<"\" has time step="<<dTemp
          <<" which is different from the time step in \""<<sFileNameBase<<"-0\" of "
          <<dTimeStep2<<std::endl;
        throw exception2(ssTemp.str(),INPUT);
      }
      
      //read in alpha
      ifIn[i].read((char*)(&dTemp),sizeof(double));
      if(dTemp!=dAlpha){
        std::stringstream ssTemp;
        ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": file \""
          <<ossFileName.str()<<"\" has alpha="<<dTemp
          <<" which is different from the alpha in \""<<sFileNameBase<<"-0\" of "
          <<dAlpha<<std::endl;
        throw exception2(ssTemp.str(),INPUT);
      }
      
      //read in gamma law
      ifIn[i].read((char*)(&nTemp),sizeof(int));
      if(nTemp!=nGammaLaw){
        std::stringstream ssTemp;
        ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": file \""
          <<ossFileName.str()<<"\" has gamma law="<<nTemp
          <<" which is different from the gamma law in \""<<sFileNameBase<<"-0\" of "
          <<nGammaLaw<<std::endl;
        throw exception2(ssTemp.str(),INPUT);
      }
      
      if(nGammaLaw==0){
        ifIn[i].read((char*)(&dTemp),sizeof(double));
        if(dTemp!=dGamma){
          std::stringstream ssTemp;
          ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": file \""
            <<ossFileName.str()<<"\" has a gamma of="<<dTemp
            <<" which is different from the gamma in \""<<sFileNameBase<<"-0\" of "
            <<dGamma<<std::endl;
          throw exception2(ssTemp.str(),INPUT);
        }
      }
      else{
        char* cBuffer=new char[nGammaLaw+1];
        ifIn[i].read(cBuffer,nGammaLaw*sizeof(char));
        cBuffer[nGammaLaw]='\0';
        std::string sTemp=cBuffer;
        delete [] cBuffer;
        if(sTemp!=sEOSFileName){
          std::stringstream ssTemp;
          ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": file \""
            <<ossFileName.str()<<"\" uses equation of state file \""<<sTemp
            <<"\" which is different from the equation of state file in \""<<sFileNameBase
            <<"-0\" of \""<<sEOSFileName<<"\""<<std::endl;
          throw exception2(ssTemp.str(),INPUT);
        }
      }
      
      //read in artificial viscosity
      ifIn[i].read((char*)(&dTemp),sizeof(double));
      if(dTemp!=dA){
        std::stringstream ssTemp;
        ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": file \""
          <<ossFileName.str()<<"\" has artificial viscosity="<<dTemp
          <<" which is different from the artificial viscosity in \""<<sFileNameBase<<"-0\" of "
          <<dA<<std::endl;
        throw exception2(ssTemp.str(),INPUT);
      }
      
      //read in artificial viscosity threshold
      ifIn[i].read((char*)(&dTemp),sizeof(double));
      if(dTemp!=dAVThreshold){
        std::stringstream ssTemp;
        ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": file \""
          <<ossFileName.str()<<"\" has artificial viscosity threshold="<<dTemp
          <<" which is different from the artificial viscosity threshold in \""<<sFileNameBase
          <<"-0\" of "<<dAVThreshold<<std::endl;
        throw exception2(ssTemp.str(),INPUT);
      }
      
      //read in processor coordinates
      nFileProcCoords[i]=new int[3];
      ifIn[i].read((char*)(nFileProcCoords[i]),3*sizeof(int));
      
      //read in number of variables and check it against file 0's
      ifIn[i].read((char*)(&nTemp),sizeof(int));
      if(nTemp!=nNumVars){
        std::stringstream ssTemp;
        ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
          <<": number of variables in file "<<i<<", "<<nTemp
          <<" does not agree with the number of variables in file 0,"
          <<nNumVars<<std::endl;
        throw exception2(ssTemp.str(),INPUT);
      }
      
      //read in variable info and check it against file 0's
      nVariableInfo[i]=new int*[nNumVars];
      for(int n=0;n<nNumVars;n++){
        nVariableInfo[i][n]=new int[4];
        ifIn[i].read((char*)(nVariableInfo[i][n]),4*sizeof(int));
        for(int l=0;l<4;l++){
          if(nVariableInfo[i][n][l]!=nVariableInfo[0][n][l]){//if variable info doesn't match first file's
            std::stringstream ssTemp;
            ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
              <<": nVariableInfo["<<i<<"]["<<n<<"]["<<l<<"]="
              <<nVariableInfo[i][n][l]<<" not equal to nVariableInfo[0]["<<n
              <<"]["<<l<<"]"<<std::endl;
            throw exception2(ssTemp.str(),INPUT);
          }
        }
      }
      
      //read in local grid size for each variable
      nFileGridSizes[i]=new int*[nNumVars];
      for(int n=0;n<nNumVars;n++){
        nFileGridSizes[i][n]=new int[3];
        ifIn[i].read((char*)(nFileGridSizes[i][n]),3*sizeof(int));
      }
      
      //read in number of ghost cells and check it against file 0's
      ifIn[i].read((char*)(&nTemp),sizeof(int));
      if(nTemp!=nNumGhostCells){
        std::stringstream ssTemp;
        ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
          <<": number of ghost cells in file "<<i<<", "<<nTemp
          <<" does not agree with the number of ghost cells in file 0,"
          <<nNumGhostCells<<std::endl;
        throw exception2(ssTemp.str(),INPUT);
      }
    }
  }
  
  //open output file
  std::ofstream ofOut;
  ofOut.open(sFileNameBase.c_str(),std::ios::binary);
  if(!ofOut.good()){
    std::stringstream ssTemp;
    ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
      <<": unable to open the file "<<sFileNameBase.c_str()<<std::endl;
    throw exception2(ssTemp.str(),INPUT);
  }
  
  //write out file type
  char cTemp='b';
  ofOut.write((char*)(&cTemp),sizeof(char));
  
  //write out file version
  int nTemp=nDumpFileVersion;
  ofOut.write((char*)(&nTemp),sizeof(int));
  
  //write out time
  ofOut.write((char*)(&dTime),sizeof(double));
  
  //write out time step index
  ofOut.write((char*)(&nTimeStepIndex),sizeof(int));
  
  //write out time step
  ofOut.write((char*)(&dTimeStep1),sizeof(double));
  
  //write out time step
  ofOut.write((char*)(&dTimeStep2),sizeof(double));
  
  //write out alpha
  ofOut.write((char*)(&dAlpha),sizeof(double));
  
  //write out nGammaLaw
  ofOut.write((char*)(&nGammaLaw),sizeof(int));
  if(nGammaLaw==0){
    ofOut.write((char*)(&dGamma),sizeof(double));
  }
  else{
    ofOut.write((char*)(sEOSFileName.c_str()),nGammaLaw*sizeof(char));
  }
  
  //read in artificial viscosity
  ofOut.write((char*)(&dA),sizeof(double));
  
  //read in artificial viscosity threshold
  ofOut.write((char*)(&dAVThreshold),sizeof(double));
  
  //write out global grid dims
  ofOut.write((char*)(nGlobalGridDims),3*sizeof(int));
  
  //write out periodicity
  ofOut.write((char*)(nPeriodic),3*sizeof(int));
  
  //write out number of 1D Zones
  ofOut.write((char*)(&nNum1DZones),sizeof(int));
  
  //write out number of ghostcells
  ofOut.write((char*)(&nNumGhostCells),sizeof(int));
  
  //write out number of variables
  ofOut.write((char*)(&nNumVars),sizeof(int));
  
  //write out variable info
  for(int n=0;n<nNumVars;n++){
    ofOut.write((char*)(nVariableInfo[0][n]),4*sizeof(int));
  }
  
  //write out the grid
  for(int n=0;n<nNumVars;n++){
    
    //read in/write out inner 1D grid
    int nSize[3];
    if(nNumFiles==1){//only have a 1D region
      nSize[0]=nNum1DZones+2*nNumGhostCells+nVariableInfo[0][n][0];
      if(nVariableInfo[0][n][0]==-1){
        nSize[0]=0;
      }
      nSize[1]=1;
      nSize[2]=1;
    }
    else{
      nSize[0]=nNum1DZones+nNumGhostCells+nVariableInfo[0][n][0];
      if(nVariableInfo[0][n][0]==-1){
        nSize[0]=0;
      }
      nSize[1]=1;
      nSize[2]=1;
    }
    double *dRow=new double[nSize[2]];
    for(int i=0;i<nSize[0];i++){
      for(int j=0;j<nSize[1];j++){
        ifIn[0].read((char*)(dRow),nSize[2]*sizeof(double));
        ofOut.write((char*)(dRow),nSize[2]*sizeof(double));
      }
    }
    delete [] dRow;
    
    //throw away outter 1D grid ghost cells
    if(nNumFiles!=1){
      int nSize2[3]={
        nNum1DZones+2*nNumGhostCells+nVariableInfo[0][n][0]
        ,nGlobalGridDims[1]
        ,nGlobalGridDims[2]};
      if(nVariableInfo[0][n][1]==-1){
        nSize2[1]=nGlobalProcDims[1];
      }
      if(nVariableInfo[0][n][2]==-1){
        nSize2[2]=nGlobalProcDims[2];
      }
      if(nVariableInfo[0][n][0]==-1){
        nSize2[0]=0;
      }
      dRow=new double[nSize2[2]];
      for(int i=nSize[0];i<nSize2[0];i++){
        for(int j=0;j<nSize2[1];j++){
          ifIn[0].read((char*)(dRow),nSize2[2]*sizeof(double));
        }
      }
      delete [] dRow;
    }
    
    //allocate space to hold a row
    int nRowSize;
    nRowSize=nGlobalGridDims[2]+2*nNumGhostCells;
    if(nVariableInfo[0][n][2]==-1){
      nRowSize=1;
    }
    dRow=new double[nRowSize];//need a new one for each variable
    
    int nGhostCellsX=1;
    if(nVariableInfo[0][n][0]==-1){
      nGhostCellsX=0;
    }
    int nGhostCellsY=1;
    if(nVariableInfo[0][n][1]==-1){
      nGhostCellsY=0;
    }
    int nGhostCellsZ=1;
    if(nVariableInfo[0][n][2]==-1){
      nGhostCellsZ=0;
    }
    
    for(int i=1;i<nGlobalProcDims[0];i++){//loop over processors in x-direction
      int nSizeX=nFileGridSizes[(i-1)*nGlobalProcDims[2]
        *nGlobalProcDims[1]+1][n][0]+nGhostCellsX*2*nNumGhostCells;
      for(int l=0;l<nSizeX;l++){
        for(int j=0;j<nGlobalProcDims[1];j++){//loop over processors in y-direction
          int nSizeY=nFileGridSizes[j*nGlobalProcDims[2]+1][n][1]
            +nGhostCellsY*2*nNumGhostCells;
          for(int p=0;p<nSizeY;p++){
            for(int k=0;k<nGlobalProcDims[2];k++){
            
              //fill up a row in z direction and write it out
              //current file index
              int nIndex=k+j*nGlobalProcDims[2]+(i-1)*nGlobalProcDims[2]
                *nGlobalProcDims[1]+1;
              //get size of row in current file
              int nRowSize=nFileGridSizes[nIndex][n][2];
              if(k==0&&nVariableInfo[0][n][2]!=-1){//if first processor or last processor in row
                nRowSize=nRowSize+nNumGhostCells;//add ghost cells
              }
              if(k==nGlobalProcDims[2]-1&&nVariableInfo[0][n][2]!=-1){//if last processor in the row
                nRowSize=nRowSize+nNumGhostCells;//add ghost cells 
              }
              
              //throw away inner ghost cell if not first processor in dimension 2
              double *dTemp;
              if(k!=0&&nVariableInfo[0][n][2]!=-1){//provided dimension 2 is defined for var n
                dTemp=new double[nNumGhostCells];
                ifIn[nIndex].read((char*)(dTemp),nNumGhostCells*sizeof(double));
                delete [] dTemp;
              }
              dTemp=new double[nRowSize];
              ifIn[nIndex].read((char*)(dTemp),nRowSize*sizeof(double));
              
              //write out plane if it is not the first and last plane (x-direction)
              if((l>=nGhostCellsX*nNumGhostCells
                 &&l<nFileGridSizes[(i-1)*nGlobalProcDims[2]
                 *nGlobalProcDims[1]+1][n][0]+nGhostCellsX*nNumGhostCells)
                
                //or it is the first processor in the 0 dimension and it is a ghost cell
                ||((i==0&&l<nGhostCellsX*nNumGhostCells)
                
                //or it is the last processor in the 0 dimension and it is a ghost cell
                ||((i==nGlobalProcDims[0]-1)
                &&l>=nFileGridSizes[(i-1)*nGlobalProcDims[2]
                *nGlobalProcDims[1]+1][n][0]+nGhostCellsX*nNumGhostCells))
                ){
                
                //write out row if it is not a ghost cell row (y-direction)
                if((p>=nGhostCellsY*nNumGhostCells
                  &&p<nFileGridSizes[j*nGlobalProcDims[2]+1][n][1]
                  +nGhostCellsY*nNumGhostCells)
                  
                  //or if it is the first processor in the 1 dimension and it is a ghost row
                  ||((j==0&&p<nGhostCellsY*nNumGhostCells)
                  
                  //or if it is the last processor in the 1 dimension and it is a ghost row
                  ||(j==nGlobalProcDims[1]-1
                  &&p>=nFileGridSizes[j*nGlobalProcDims[2]+1][n][1]+nGhostCellsY*nNumGhostCells))
                  ){
                  if( ((j==0&&nVariableInfo[0][n][1]==-1)||(nVariableInfo[0][n][1]!=-1))
                    &&((k==0&&nVariableInfo[0][n][2]==-1)||(nVariableInfo[0][n][2]!=-1))
                    ){
                    
                    //if variable defined in x-direction || the first processor in x-direction after 0
                    if(nVariableInfo[0][n][0]!=-1||i==1){
                      ofOut.write((char*)(dTemp),nRowSize*sizeof(double));
                    }
                  }
                }
              }
              delete [] dTemp;
              
              //throw away outter ghost cell if not last in row
              if(k!=nGlobalProcDims[2]-1&&nVariableInfo[0][n][2]!=-1){
                dTemp=new double[nNumGhostCells];
                ifIn[nIndex].read((char*)(dTemp),nNumGhostCells*sizeof(double));
                delete [] dTemp;
              }
            }
          }
        }
      }
    }
    delete [] dRow;
  }
  
  ofOut.close();
  //delete allocated memory
  /*for(int i=0;i<nNumFiles;i++){
    delete [] nFileGridSizes[i];
    delete [] nFileProcCoords[i];
  }
  delete [] nFileGridSizes;
  delete [] nFileProcCoords;
  delete [] ifIn;*/
}
bool bFileExists(std::string strFilename){
  std::ifstream ifTest;
  ifTest.open(strFilename.c_str(),std::ios::in);
  if(!ifTest){
    return false;//doesn't exsist
  }
  else{
    ifTest.close();
    return true;//does exsist
  }
}
void convertCollAsciiToBin(std::string sFileName){//tested
  
  //open input file
  if(sFileName.size()==0){
    std::stringstream ssTemp;
    ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
      <<": no input file specified\n";
    throw exception2(ssTemp.str(),INPUT);
  }
  std::ifstream ifFile;
  ifFile.open(sFileName.c_str());
  if(!ifFile.good()){
    std::stringstream ssTemp;
    ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": input file \""
      <<sFileName<<"\" didn't open properly\n";
    throw exception2(ssTemp.str(),INPUT);
  }
  
  //check to see if it is ascii or binary
  char cTemp;
  ifFile>>cTemp;
  if(cTemp!='a'){//not an ascii file
    std::stringstream ssTemp;
    ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": input file \""
      <<sFileName<<"\" not an ASCII file\n";
    throw exception2(ssTemp.str(),INPUT);
  }
  
  //check to see if it is the right version
  int nVersion;
  ifFile>>nVersion;
  if(nVersion!=nDumpFileVersion){//file isn't the supported version
    std::stringstream ssTemp;
    ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": input file \""
      <<sFileName<<"\" version \""<<nVersion
      <<"\" is not the version currently supported \""<<nDumpFileVersion<<"\".\n";
    throw exception2(ssTemp.str(),INPUT);
  }
  
  //open output file
  std::stringstream ssTemp;
  ssTemp<<sFileName.substr(0,sFileName.size()-4);
  
  std::ofstream ofFile;
  ofFile.open(ssTemp.str().c_str(),std::ios::binary);
  if(!ofFile.good()){
    std::stringstream ssTemp;
    ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": output file \""
      <<ssTemp.str()<<"\" didn't open properly\n";
    throw exception2(ssTemp.str(),INPUT);
  }
  
  //write out that file is binary
  cTemp='b';//converting to binary
  ofFile.write((char*)(&cTemp),sizeof(char));
  
  //write out version of file
  ofFile.write((char*)(&nVersion),sizeof(int));
  
  //read in/write out time
  double dTime;
  ifFile>>dTime;
  ofFile.write((char*)(&dTime),sizeof(double));
  
  //read in/write out time step index
  int nTimeStepIndex;
  ifFile>>nTimeStepIndex;
  ofFile.write((char*)(&nTimeStepIndex),sizeof(int));
  
  //read in/write out timestep
  double dTimeStep1;
  ifFile>>dTimeStep1;
  ofFile.write((char*)(&dTimeStep1),sizeof(double));
  
  //read in/write out timestep
  double dTimeStep2;
  ifFile>>dTimeStep2;
  ofFile.write((char*)(&dTimeStep2),sizeof(double));
  
  //read in/write out alpha
  double dAlpha;
  ifFile>>dAlpha;
  ofFile.write((char*)(&dAlpha),sizeof(double));
  
  int nGammaLaw;
  ifFile>>nGammaLaw;
  if(nGammaLaw==0){
    double dGamma;
    ifFile>>dGamma;
    ofFile.write((char*)(&nGammaLaw),sizeof(int));
    ofFile.write((char*)(&dGamma),sizeof(double));
  }
  else{
    std::string sEOSTable;
    ifFile>>sEOSTable;
    ofFile.write((char*)(&nGammaLaw),sizeof(int));
    ofFile.write(sEOSTable.c_str(),sEOSTable.size()*sizeof(char));
  }
  
  //read in/write out artificial viscosity
  double dAV;
  ifFile>>dAV;
  ofFile.write((char*)(&dAV),sizeof(double));
  
  //read in/write out artificial viscosity threshold
  double dAVThreshold;
  ifFile>>dAVThreshold;
  ofFile.write((char*)(&dAVThreshold),sizeof(double));
  
  //read in global grid size, periodicity, number of 1D Zones, number of ghost cells,ints,
  int nTemp;
  for(int i=0;i<8;i++){
    ifFile>>nTemp;
    ofFile.write((char*)(&nTemp),sizeof(int));
  }
  
  //read in/writeout variable info
  int nNumVars;
  ifFile>>nNumVars;
  ofFile.write((char*)(&nNumVars),sizeof(int));
  for(int i=0;i<nNumVars;i++){
    ifFile>>nTemp;
    ofFile.write((char*)(&nTemp),sizeof(int));//read x
    ifFile>>nTemp;
    ofFile.write((char*)(&nTemp),sizeof(int));//read y
    ifFile>>nTemp;
    ofFile.write((char*)(&nTemp),sizeof(int));//read z
    ifFile>>nTemp;
    ofFile.write((char*)(&nTemp),sizeof(int));//read t dependence
  }
  
  //read in rest of grid (all doubles) until eof reached
  double dTemp;
  /*while(!ifFile.eof()){
    ifFile>>dTemp;
    ofFile.write((char*)(&dTemp),sizeof(double));
    
    //clean out spaces, and return line characters
    char cTemp;
    while(ifFile.peek()=='\n'||ifFile.peek()=='\r'||ifFile.peek()==' '){
      ifFile.get(cTemp);
    }
  }*/
  while(ifFile>>dTemp){
    ofFile.write((char*)(&dTemp),sizeof(double));
  }
}
void makeRadialProFromColBin(std::string sFileName){//updated
  
  //open input file
  std::string sExtension=sFileName.substr(sFileName.size()-4,1);
  if(sExtension.compare(".")==0){//if there is an extension remove it
    sFileName=sFileName.substr(0,sFileName.size()-4);
  }
  if(sFileName.size()==0){
    std::stringstream ssTemp;
    ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
      <<": no input file specified\n";
    throw exception2(ssTemp.str(),INPUT);
  }
  std::ifstream ifFile;
  ifFile.open(sFileName.c_str(),std::ios::binary);
  if(!ifFile.good()){
    std::stringstream ssTemp;
    ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": input file \""
      <<sFileName<<"\" didn't open properly\n";
    throw exception2(ssTemp.str(),INPUT);
  }
  
  //check that it is a binary file
  char cTemp;
  ifFile.read((char*)(&cTemp),sizeof(char));
  if(cTemp!='b'){
    std::stringstream ssTemp;
    ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": input file \""
      <<sFileName<<"\" isn't a binary file.\n";
    throw exception2(ssTemp.str(),INPUT);
  }
  
  //check that it is the correct version
  int nTemp;
  ifFile.read((char*)(&nTemp),sizeof(int));
  if(nTemp!=nDumpFileVersion){
    std::stringstream ssTemp;
    ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": inpput file \""
      <<sFileName<<"\" version \""<<nTemp
      <<"\" isn't the supported version \""<<nDumpFileVersion<<"\".\n";
    throw exception2(ssTemp.str(),INPUT);
  }
  
  //read in time
  double dTime;
  ifFile.read((char*)(&dTime),sizeof(double));
  
  //read in the time step index
  int nTimeStepIndex;
  ifFile.read((char*)(&nTimeStepIndex),sizeof(int));
  
  //read in the time step
  double dTimeStep1;
  ifFile.read((char*)(&dTimeStep1),sizeof(double));
  
  //read in the time step
  double dTimeStep2;
  ifFile.read((char*)(&dTimeStep2),sizeof(double));
  
  //read in alpha
  double dAlpha;
  ifFile.read((char*)(&dAlpha),sizeof(double));
  
  //read in gamma law
  int nGammaLaw;
  ifFile.read((char*)(&nGammaLaw),sizeof(int));
  
  double dGamma;
  std::string sEOSTable;
  eos eosTable;
  if(nGammaLaw==0){
    ifFile.read((char*)(&dGamma),sizeof(double));
  }
  else{
    char *cBuffer=new char[nGammaLaw+1];
    ifFile.read(cBuffer,nGammaLaw*sizeof(char));
    cBuffer[nGammaLaw]='\0';
    sEOSTable=cBuffer;
    delete [] cBuffer;
    eosTable.readBin(sEOSTable);
  }
  
  //read in artificial viscosity
  double dA;
  ifFile.read((char*)(&dA),sizeof(double));
  
  //read in artificial viscosity threshold
  double dAVThreshold;
  ifFile.read((char*)(&dAVThreshold),sizeof(double));
  
  //read in global grid size
  int nSizeGlobe[3];
  ifFile.read((char*)(nSizeGlobe),3*sizeof(int));
  
  //read in periodicity
  int nPeriodic[3];
  ifFile.read((char*)(nPeriodic),3*sizeof(int));
  
  //read in number of 1D Zones
  int nNum1DZones;
  ifFile.read((char*)(&nNum1DZones),sizeof(int));
  
  //read in number of ghostcells
  int nNumGhostCells;
  ifFile.read((char*)(&nNumGhostCells),sizeof(int));
  
  //read in number of grid variables
  int nNumVars;
  ifFile.read((char*)(&nNumVars),sizeof(int));
  
  //get variable info, and set grid sizes
  int **nSize=new int*[nNumVars];
  int **nVarInfo=new int*[nNumVars];
  int l;
  for(int n=0;n<nNumVars;n++){
    nSize[n]=new int[3];
    nVarInfo[n]=new int[3];
    ifFile.read((char*)(nVarInfo[n]),(4)*sizeof(int));
    for(l=0;l<3;l++){
      if(nSizeGlobe[l]==1){
        nVarInfo[n][l]=-1;
      }
      if(nVarInfo[n][l]==-1){//variable not defined in direction l
        nSize[n][l]=1;
      }
      else if(nVarInfo[n][l]==1&&l==0){//interface variable
        nSize[n][l]=nSizeGlobe[l]+1;
      }
      else{
        nSize[n][l]=nSizeGlobe[l];
      }
    }
  }
  
  //figure out number of dimensions
  int nNumDims=0;
  if(nSizeGlobe[0]>1){
    nNumDims++;
  }
  if(nSizeGlobe[1]>1){
    nNumDims++;
  }
  if(nSizeGlobe[2]>1){
    nNumDims++;
  }
  
  //set variable indices
  int nNumIntVars=0;
  if(nGammaLaw==0){//using gamma law gas
    if(nNumDims==1){
      nNumIntVars=3;
      nM=0;
      nDM=1;
      nR=2;
      nD=3;
      nU=4;
      nU0=5;
      nE=6;
      nP=nNumVars+0;
      nQ=nNumVars+1;
      nKE=nNumVars+2;
      nV=-1;
      nW=-1;
      nT=-1;
      nTheta=-1;
      nPhi=-1;
      nKappa=-1;
      nGamma=-1;
    }
    else if(nNumDims==2){
      nNumIntVars=3;
      nM=0;
      nTheta=1;
      nDM=2;
      nR=3;
      nD=4;
      nU=5;
      nU0=6;
      nV=7;
      nE=8;
      nP=nNumVars+0;
      nQ=nNumVars+1;
      nKE=nNumVars+2;
      nW=-1;
      nT=-1;
      nPhi=-1;
      nKappa=-1;
      nGamma=-1;
    }
    else if(nNumDims==3){
      nNumIntVars=3;
      nM=0;
      nTheta=1;
      nPhi=2;
      nDM=3;
      nR=4;
      nD=5;
      nU=6;
      nU0=7;
      nV=8;
      nW=9;
      nE=10;
      nP=nNumVars+0;
      nQ=nNumVars+1;
      nKE=nNumVars+2;
      nT=-1;
      nKappa=-1;
      nGamma=-1;
    }
  }
  else{//using a tabulated equaiton of state
    if(nNumDims==1){
      nNumIntVars=8;
      nM=0;
      nDM=1;
      nR=2;
      nD=3;
      nU=4;
      nU0=5;
      nT=6;
      nE=nNumVars+0;
      nQ=nNumVars+1;
      nP=nNumVars+2;
      nKappa=nNumVars+3;
      nGamma=nNumVars+4;
      nL_rad=nNumVars+5;
      nL_con=nNumVars+6;
      nKE=nNumVars+7;
      nV=-1;
      nW=-1;
      nTheta=-1;
      nPhi=-1;
    }
    else if(nNumDims==2){
      nNumIntVars=8;
      nM=0;
      nTheta=1;
      nDM=2;
      nR=3;
      nD=4;
      nU=5;
      nU0=6;
      nV=7;
      nT=8;
      nE=nNumVars+0;
      nQ=nNumVars+1;
      nP=nNumVars+2;
      nKappa=nNumVars+3;
      nGamma=nNumVars+4;
      nL_rad=nNumVars+5;
      nL_con=nNumVars+6;
      nKE=nNumVars+7;
      nPhi=-1;
      nW=-1;
    }
    else if(nNumDims==3){
      nNumIntVars=8;
      nM=0;
      nTheta=1;
      nPhi=2;
      nDM=3;
      nR=4;
      nD=5;
      nU=6;
      nU0=7;
      nV=8;
      nW=9;
      nT=10;
      nE=nNumVars+0;
      nQ=nNumVars+1;
      nP=nNumVars+2;
      nKappa=nNumVars+3;
      nGamma=nNumVars+4;
      nL_rad=nNumVars+5;
      nL_con=nNumVars+6;
      nKE=nNumVars+7;
    }
  }
  
  //read in grid
  double ****dGrid=new double***[nNumVars];
  int nGhostCellsX;
  int nGhostCellsY;
  int nGhostCellsZ;
  int nSizeX1;
  int nSizeX2;
  int nStartY;
  int nEndY;
  int nSizeY;
  int nStartZ;
  int nEndZ;
  int nSizeZ;
  int i;
  int j;
  int k;
  double *dTempArray;
  double dSum;
  int nCount;
  for(int n=0;n<nNumVars;n++){
    
    nGhostCellsX=1;
    if(nVarInfo[n][0]==-1){
      nGhostCellsX=0;
    }
    nGhostCellsY=1;
    if(nVarInfo[n][1]==-1){
      nGhostCellsY=0;
    }
    nGhostCellsZ=1;
    if(nVarInfo[n][2]==-1){
      nGhostCellsZ=0;
    }
    
    //make some space to hold the variables
    dGrid[n]=new double**[nSize[n][0]+nGhostCellsX*2*nNumGhostCells];
    
    //read in 1D part of the grid
    nSizeX1=nGhostCellsX*(nNum1DZones+nNumGhostCells);//may be need to +1 if only one proc and variable in interface centered
    if (nVarInfo[n][0]==1&&nPeriodic[0]==0){
      nSizeX1=nGhostCellsX*(nNum1DZones+1+nNumGhostCells);
    }
    nSizeY=1;
    nSizeZ=1;
    for(i=0;i<nSizeX1;i++){
      dGrid[n][i]=new double*[nSizeY];
      for(j=0;j<nSizeY;j++){
        dGrid[n][i][j]=new double[nSizeZ];
        ifFile.read((char*)(dGrid[n][i][j]),nSizeZ*sizeof(double));
      }
    }
    
    //read in the rest of the grid
    nSizeX2=nSize[n][0]+nGhostCellsX*2*nNumGhostCells;
    nSizeY=nSize[n][1]+nGhostCellsY*2*nNumGhostCells;//assume y and z are always periodic
    nSizeZ=nSize[n][2]+nGhostCellsZ*2*nNumGhostCells;
    dTempArray=new double[nSizeZ];
    for(i=nSizeX1;i<nSizeX2;i++){
      dGrid[n][i]=new double*[nSizeY];
      for(j=0;j<nSizeY;j++){
        dGrid[n][i][j]=new double[nSizeZ];
        ifFile.read((char*)(dGrid[n][i][j]),nSizeZ*sizeof(double));
      }
    }
  }
  ifFile.close();
  
  //radialize the grid
  double **dMax=new double*[nNumVars+nNumIntVars];
  double **dMin=new double*[nNumVars+nNumIntVars];
  double **dAve=new double*[nNumVars+nNumIntVars];
  int **nMaxJIndex=new int*[nNumVars+nNumIntVars];
  int **nMaxKIndex=new int*[nNumVars+nNumIntVars];
  int **nMinJIndex=new int*[nNumVars+nNumIntVars];
  int **nMinKIndex=new int*[nNumVars+nNumIntVars];
  double dMaxTemp;
  double dMinTemp;
  for(int n=0;n<nNumVars;n++){
    
    nGhostCellsX=1;
    if(nVarInfo[n][0]==-1){
      nGhostCellsX=0;
    }
    nGhostCellsY=1;
    if(nVarInfo[n][1]==-1){
      nGhostCellsY=0;
    }
    nGhostCellsZ=1;
    if(nVarInfo[n][2]==-1){
      nGhostCellsZ=0;
    }
    
    //make some space to hold max,mine and average
    dMax[n]=new double[nSize[n][0]+nGhostCellsX*2*nNumGhostCells];
    dMin[n]=new double[nSize[n][0]+nGhostCellsX*2*nNumGhostCells];
    dAve[n]=new double[nSize[n][0]+nGhostCellsX*2*nNumGhostCells];
    
    nMaxJIndex[n]=new int[nSize[n][0]+nGhostCellsX*2*nNumGhostCells];
    nMaxKIndex[n]=new int[nSize[n][0]+nGhostCellsX*2*nNumGhostCells];
    nMinJIndex[n]=new int[nSize[n][0]+nGhostCellsX*2*nNumGhostCells];
    nMinKIndex[n]=new int[nSize[n][0]+nGhostCellsX*2*nNumGhostCells];
    
    //read in 1D part of the grid
    nSizeX1=nGhostCellsX*(nNum1DZones+nNumGhostCells);//may be need to +1 if only one proc and variable in interface centered
    if (nVarInfo[n][0]==1&&nPeriodic[0]==0){
      nSizeX1=nGhostCellsX*(nNum1DZones+1+nNumGhostCells);
    }
    nSizeY=1;
    nSizeZ=1;
    for(i=0;i<nSizeX1;i++){
      //find average max, and min
      dMax[n][i]=dGrid[n][i][0][0];
      dMin[n][i]=dGrid[n][i][0][0];
      dAve[n][i]=dGrid[n][i][0][0];
      nMaxJIndex[n][i]=0;
      nMaxKIndex[n][i]=0;
      nMinJIndex[n][i]=0;
      nMinKIndex[n][i]=0;
    }
    
    //read in the rest of the grid
    nSizeX2=nSize[n][0]+nGhostCellsX*2*nNumGhostCells;
    nSizeY=nSize[n][1]+nGhostCellsY*2*nNumGhostCells;
    nSizeZ=nSize[n][2]+nGhostCellsZ*2*nNumGhostCells;
    nStartY=nGhostCellsY*nNumGhostCells;
    nEndY=nSize[n][1]+nStartY;
    nStartZ=nGhostCellsZ*nNumGhostCells;
    nEndZ=nSize[n][2]+nStartZ;
    for(i=nSizeX1;i<nSizeX2;i++){
      dMaxTemp=-1.0*std::numeric_limits<double>::max();
      dMinTemp=std::numeric_limits<double>::max();
      dSum=0.0;
      nCount=0;
      for(j=nStartY;j<nEndY;j++){
        for(k=nStartZ;k<nEndZ;k++){
          //find average max, and min
          if(dGrid[n][i][j][k]>dMaxTemp){
            dMaxTemp=dGrid[n][i][j][k];
            nMaxJIndex[n][i]=j;
            nMaxKIndex[n][i]=k;
          }
          if(dGrid[n][i][j][k]<dMinTemp){
            dMinTemp=dGrid[n][i][j][k];
            nMinJIndex[n][i]=j;
            nMinKIndex[n][i]=k;
          }
          dSum+=dGrid[n][i][j][k];
          nCount++;
        }
      }
      dMax[n][i]=dMaxTemp;
      dMin[n][i]=dMinTemp;
      dAve[n][i]=dSum/double(nCount);
    }
  }
  
  //allocate space for internal variables
  for(int n=nNumVars;n<nNumVars+nNumIntVars;n++){
    dMax[n]=new double[nSize[nD][0]+nGhostCellsX*2*nNumGhostCells];
    dMin[n]=new double[nSize[nD][0]+nGhostCellsX*2*nNumGhostCells];
    dAve[n]=new double[nSize[nD][0]+nGhostCellsX*2*nNumGhostCells];
    nMaxJIndex[n]=new int[nSize[nD][0]+nGhostCellsX*2*nNumGhostCells];
    nMaxKIndex[n]=new int[nSize[nD][0]+nGhostCellsX*2*nNumGhostCells];
    nMinJIndex[n]=new int[nSize[nD][0]+nGhostCellsX*2*nNumGhostCells];
    nMinKIndex[n]=new int[nSize[nD][0]+nGhostCellsX*2*nNumGhostCells];
  }
  
  if(nGammaLaw!=0){//set P,E,kappa,gamma, Q, L_rad and L_con, and KE
    
    //allocate space
    nGhostCellsX=1;
    if(nVarInfo[nD][0]==-1){/*all internal variables are cetnered quantities, will be the same as 
      the density*/
      nGhostCellsX=0;
    }
    nGhostCellsY=1;
    if(nVarInfo[nD][1]==-1){
      nGhostCellsY=0;
    }
    nGhostCellsZ=1;
    if(nVarInfo[nD][2]==-1){
      nGhostCellsZ=0;
    }
    
    double dP_i;
    double dE_i;
    double dKappa_i;
    double dGamma_i;
    double dCp_i;
    double dCp_ip1;
    double dCp_ip1half;
    double dRho_ip1half;
    double dTAve_i;
    double dTAve_ip1;
    double dTAve_ip1half;
    double dT_ip1halfjk;
    double dP_ip1;
    double dE_ip1;
    double dKappa_ip1;
    double dKappa_ip1half;
    double dGamma_ip1;
    double dQ;
    double dQ0=0.0;
    double dQ1=0.0;
    double dQ2=0.0;
    double dMaxE;
    double dMinE;
    double dSumE;
    double dMaxP;
    double dMinP;
    double dSumP;
    double dMaxKappa;
    double dMinKappa;
    double dSumKappa;
    double dMaxGamma;
    double dMinGamma;
    double dSumGamma;
    double dMaxQ;
    double dMinQ;
    double dSumQ;
    double dRSq_i;
    double dA_ip1half;
    double dA_im1half;
    double dTheta_j;
    double dTheta_jp1half;
    double dTheta_jm1half;
    double dA_jp1half;
    double dA_jm1half;
    double dA_j;
    double dASq=dA*dA;
    double dC;
    double dDVDtThreshold;
    double dDVDt_mthreshold;
    double dDVDt;
    double dLSum_rad=0.0;
    double dLSum_con=0.0;
    double dAreaSum=0.0;
    double dR_i;
    double dRSq_ip1half;
    double dT4_ip1;
    double dT4_i;
    double dArea;
    double dArea1;
    double dArea2;
    double dPhi_kp1half;
    double dPhi_km1half;
    double dU_i;
    
    //set 1D part of the grid
    nSizeX1=nGhostCellsX*(nNum1DZones+nNumGhostCells);/*maybe need to +1 if only one proc and 
      variable in interface centered*/
    if (nVarInfo[nD][0]==1&&nPeriodic[0]==0){
      nSizeX1=nGhostCellsX*(nNum1DZones+1+nNumGhostCells);
    }
    nSizeY=1;
    nSizeZ=1;
    for(i=0;i<nSizeX1;i++){//find average max, and min in 1D region
      
      //get P,E,Kappa,Gamma
      eosTable.getPEKappaGamma(dGrid[nT][i][0][0],dGrid[nD][i][0][0],dP_i,dE_i,dKappa_i,dGamma_i);
      eosTable.getPEKappaGamma(dGrid[nT][i+1][0][0],dGrid[nD][i+1][0][0],dP_ip1,dE_ip1,dKappa_ip1
        ,dGamma_ip1);
      
      //calculate Q
      dR_i=(dGrid[nR][i+1][0][0]+dGrid[nR][i][0][0])*0.5;
      dRSq_i=dR_i*dR_i;
      dA_ip1half=dGrid[nR][i+1][0][0]*dGrid[nR][i+1][0][0];
      dA_im1half=dGrid[nR][i][0][0]*dGrid[nR][i][0][0];
      dC=sqrt(dGamma_i*dP_i/dGrid[nD][i][0][0]);
      dDVDtThreshold=dAVThreshold*dC;
      dDVDt=(dA_ip1half*dGrid[nU][i+1][0][0]
        -dA_im1half*dGrid[nU][i][0][0])/dRSq_i;
      if(dDVDt<-1.0*dDVDtThreshold){//being compressed
        dDVDt_mthreshold=dDVDt+dDVDtThreshold;
        dQ=dASq*dGrid[nD][i][0][0]*dDVDt_mthreshold*dDVDt_mthreshold;
      }
      else{
        dQ=0.0;
      }
      
      //calculate luminosity from cell and add to sum
      dLSum_rad=0.0;
      dArea=dA_ip1half*4.0*dPi;
      dT4_i=pow(dGrid[nT][i][0][0],4);
      dT4_ip1=pow(dGrid[nT][i+1][0][0],4);
      dKappa_ip1half=(dT4_i/dKappa_i+dT4_ip1/dKappa_ip1)
        /(dT4_i+dT4_ip1);
      dAve[nL_rad][i]=-16.0*dPi*dSigma*dA_ip1half*dKappa_ip1half
        /3.0*(dT4_ip1-dT4_i)/(dGrid[nDM][i][0][0]+dGrid[nDM][i+1][0][0])
        *2.0*dArea;
      dAve[nL_con][i]=0.0;
      dU_i=(dGrid[nU0][i+1][0][0]+dGrid[nU0][i][0][0])*0.5;
      dAve[nKE][i]=0.5*dGrid[nDM][i][0][0]*dU_i*dU_i;
      dMax[nE][i]=dE_i;
      dMin[nE][i]=dE_i;
      dAve[nE][i]=dE_i;
      dMax[nP][i]=dP_i;
      dMin[nP][i]=dP_i;
      dAve[nP][i]=dP_i;
      dMax[nKappa][i]=dKappa_i;
      dMin[nKappa][i]=dKappa_i;
      dAve[nKappa][i]=dKappa_i;
      dMax[nGamma][i]=dGamma_i;
      dMin[nGamma][i]=dGamma_i;
      dAve[nGamma][i]=dGamma_i;
      dMax[nQ][i]=dQ;
      dMin[nQ][i]=dQ;
      dAve[nQ][i]=dQ;
      nMaxJIndex[nP][i]=0;
      nMaxKIndex[nP][i]=0;
      nMinJIndex[nP][i]=0;
      nMinKIndex[nP][i]=0;
      nMaxJIndex[nE][i]=0;
      nMaxKIndex[nE][i]=0;
      nMinJIndex[nE][i]=0;
      nMinKIndex[nE][i]=0;
      nMaxJIndex[nKappa][i]=0;
      nMaxKIndex[nKappa][i]=0;
      nMinJIndex[nKappa][i]=0;
      nMinKIndex[nKappa][i]=0;
      nMaxJIndex[nGamma][i]=0;
      nMaxKIndex[nGamma][i]=0;
      nMinJIndex[nGamma][i]=0;
      nMinKIndex[nGamma][i]=0;
      nMaxJIndex[nQ][i]=0;
      nMaxKIndex[nQ][i]=0;
      nMinJIndex[nQ][i]=0;
      nMinKIndex[nQ][i]=0;
      nMaxJIndex[nL_rad][i]=0;
      nMaxKIndex[nL_rad][i]=0;
      nMinJIndex[nL_rad][i]=0;
      nMinKIndex[nL_rad][i]=0;
      nMaxJIndex[nKE][i]=0;
      nMaxKIndex[nKE][i]=0;
      nMinJIndex[nKE][i]=0;
      nMinKIndex[nKE][i]=0;
    }
    
    //set the rest of the grid
    nSizeX2=nSize[nD][0]+nGhostCellsX*2*nNumGhostCells;
    nSizeY=nSize[nD][1]+nGhostCellsY*2*nNumGhostCells;
    nSizeZ=nSize[nD][2]+nGhostCellsZ*2*nNumGhostCells;
    nStartY=nGhostCellsY*nNumGhostCells;
    nEndY=nSize[nD][1]+nStartY;
    nStartZ=nGhostCellsZ*nNumGhostCells;
    nEndZ=nSize[nD][2]+nStartZ;
    for(i=nSizeX1;i<nSizeX2;i++){
      dMaxE=-1.0*std::numeric_limits<double>::max();
      dMinE=std::numeric_limits<double>::max();
      dSumE=0.0;
      dMaxP=-1.0*std::numeric_limits<double>::max();
      dMinP=std::numeric_limits<double>::max();
      dSumP=0.0;
      dMaxKappa=-1.0*std::numeric_limits<double>::max();
      dMinKappa=std::numeric_limits<double>::max();
      dSumKappa=0.0;
      dMaxGamma=-1.0*std::numeric_limits<double>::max();
      dMinGamma=std::numeric_limits<double>::max();
      dSumGamma=0.0;
      dMaxQ=-1.0*std::numeric_limits<double>::max();
      dMinQ=std::numeric_limits<double>::max();
      dSumQ=0.0;
      nCount=0;
      dR_i=(dGrid[nR][i+1][0][0]+dGrid[nR][i][0][0])*0.5;
      dRSq_ip1half=dGrid[nR][i+1][0][0]*dGrid[nR][i+1][0][0];
      dRSq_i=dR_i*dR_i;
      dA_ip1half=dGrid[nR][i+1][0][0]*dGrid[nR][i+1][0][0];
      dA_im1half=dGrid[nR][i][0][0]*dGrid[nR][i][0][0];
      dLSum_rad=0.0;
      dLSum_con=0.0;
      dAreaSum=0.0;
      dArea1=dRSq_ip1half*4.0*dPi;
      for(j=nStartY;j<nEndY;j++){
        
        if(nNumDims>1){
          dTheta_jp1half=dGrid[nTheta][0][j][0];
          if(j==0){
            dTheta_jm1half=dGrid[nTheta][0][j][0]-(dGrid[nTheta][0][j+1][0]-dGrid[nTheta][0][j][0]);
          }
          else{
            dTheta_jm1half=dGrid[nTheta][0][j-1][0];
          }
          dTheta_j=(dTheta_jp1half+dTheta_jm1half)*0.5;
          dA_jp1half=sin(dTheta_jp1half);
          dA_jm1half=sin(dTheta_jm1half);
          dA_j=sin(dTheta_j);
          dArea2=dArea1/2.0*(cos(dTheta_jm1half)-cos(dTheta_jp1half));
          dArea=dArea2;
        }
        
        for(k=nStartZ;k<nEndZ;k++){
          if(nNumDims>2){
            dPhi_kp1half=dGrid[nPhi][0][0][k];
            if(k==0){
              dPhi_km1half=dGrid[nPhi][0][0][k]-(dGrid[nPhi][0][0][k+1]-dGrid[nPhi][0][0][k]);
            }
            else{
              dPhi_km1half=dGrid[nPhi][0][0][k-1];
            }
            dArea=dArea2/(2.0*dPi)*(dPhi_kp1half-dPhi_km1half);
          }
          
          //get P,E,Kappa,Gamma, calculate luminosity from cell and add to sum
          eosTable.getPEKappaGammaCp(dGrid[nT][i][j][k],dGrid[nD][i][j][k],dP_i,dE_i,dKappa_i
            ,dGamma_i,dCp_i);
          if(i<nSizeX2-1){
            eosTable.getPEKappaGammaCp(dGrid[nT][i+1][j][k],dGrid[nD][i+1][j][k],dP_ip1,dE_ip1
              ,dKappa_ip1,dGamma_ip1,dCp_ip1);
            dT4_i=pow(dGrid[nT][i][j][k],4);
            dT4_ip1=pow(dGrid[nT][i+1][j][k],4);
            dKappa_ip1half=(dT4_i/dKappa_i+dT4_ip1/dKappa_ip1)
              /(dT4_i+dT4_ip1);
            dLSum_rad=dLSum_rad-16.0*dPi*dSigma*dRSq_ip1half*dKappa_ip1half/3.0
              *(dT4_ip1-dT4_i)/(dGrid[nDM][i][0][0]+dGrid[nDM][i+1][0][0])*2.0*dArea;
            dRho_ip1half=(dGrid[nD][i][j][k]+dGrid[nD][i+1][j][k])*0.5;
            dTAve_ip1half=(dAve[nT][i]+dAve[nT][i+1])*0.5;
            dT_ip1halfjk=(dGrid[nT][i][j][k]+dGrid[nT][i+1][j][k])*0.5;
            dCp_ip1half=(dCp_i+dCp_ip1)*0.5;
            dLSum_con=dLSum_con+dCp_ip1half*dRho_ip1half*(dT_ip1halfjk-dTAve_ip1half)
              *(dGrid[nU][i+1][j][k]-dGrid[nU0][i+1][0][0])*dArea;
          }
          else{
            //use surface boundary condition
            dLSum_rad=dLSum_rad+dSigma*dArea*pow(pow(2.0,0.25)*dGrid[nT][i][j][k],4);
            dLSum_con=0.0;
          }
          dAreaSum+=dArea;
          
          //calculate Q
          dC=sqrt(dGamma_i*dP_i/dGrid[nD][i][j][k]);
          dDVDtThreshold=dAVThreshold*dC;
          if(nNumDims>=1){
            if(i==nSizeX1){
              dDVDt=(dA_ip1half*dGrid[nU][i+1][j][k]
                -dA_im1half*dGrid[nU][i][0][0])/dRSq_i;
            }
            else{
              dDVDt=(dA_ip1half*dGrid[nU][i+1][j][k]
                -dA_im1half*dGrid[nU][i][j][k])/dRSq_i;
            }
            if(dDVDt<-1.0*dDVDtThreshold){//being compressed
              dDVDt_mthreshold=dDVDt+dDVDtThreshold;
              dQ0=dASq*dGrid[nD][i][j][k]*dDVDt_mthreshold*dDVDt_mthreshold;
            }
            else{
              dQ0=0.0;
            }
          }
          else if(nNumDims>=2){
            if(j==0){
              dDVDt=(dA_jp1half*dGrid[nV][i][j][k]
                -dA_jm1half*dGrid[nV][i][nSizeY-1][k])/dA_j;
            }
            else{
              dDVDt=(dA_jp1half*dGrid[nV][i][j][k]
                -dA_jm1half*dGrid[nV][i][j-1][k])/dA_j;
            }
            if(dDVDt<-1.0*dDVDtThreshold){//being compressed
              dDVDt_mthreshold=dDVDt+dDVDtThreshold;
              dQ1=dASq*dGrid[nD][i][j][k]
                *dDVDt_mthreshold*dDVDt_mthreshold;
            }
            else{
              dQ1=0.0;
            }
          }
          else if(nNumDims==3){
            if(k==0){
              dDVDt=(dGrid[nW][i][j][k]-dGrid[nW][i][j][nSizeZ-1]);
            }
            else{
              dDVDt=(dGrid[nW][i][j][k]-dGrid[nW][i][j][k-1]);
            }
            if(dDVDt<-1.0*dDVDtThreshold){//being compressed
              dDVDt_mthreshold=dDVDt+dDVDtThreshold;
              dQ2=dASq*dGrid[nD][i][j][k]*dDVDt_mthreshold*dDVDt_mthreshold;
            }
            else{
              dQ2=0.0;
            }
          }
          dQ=dQ0+dQ1+dQ2;
          
          if(dP_i>dMaxP){
            dMaxP=dP_i;
            nMaxJIndex[nP][i]=j;
            nMaxKIndex[nP][i]=k;
          }
          if(dP_i<dMinP){
            dMinP=dP_i;
            nMinJIndex[nP][i]=j;
            nMinKIndex[nP][i]=k;
          }
          dSumP+=dP_i;
          if(dE_i>dMaxE){
            dMaxE=dE_i;
            nMaxJIndex[nE][i]=j;
            nMaxKIndex[nE][i]=k;
          }
          if(dE_i<dMinE){
            dMinE=dE_i;
            nMinJIndex[nE][i]=j;
            nMinKIndex[nE][i]=k;
          }
          dSumE+=dE_i;
          if(dKappa_i>dMaxKappa){
            dMaxKappa=dKappa_i;
            nMaxJIndex[nKappa][i]=j;
            nMaxKIndex[nKappa][i]=k;
          }
          if(dKappa_i<dMinKappa){
            dMinKappa=dKappa_i;
            nMinJIndex[nKappa][i]=j;
            nMinKIndex[nKappa][i]=k;
          }
          dSumKappa+=dKappa_i;
          if(dGamma_i>dMaxGamma){
            dMaxGamma=dGamma_i;
            nMaxJIndex[nGamma][i]=j;
            nMaxKIndex[nGamma][i]=k;
          }
          if(dGamma_i<dMinGamma){
            dMinGamma=dGamma_i;
            nMinJIndex[nGamma][i]=j;
            nMinKIndex[nGamma][i]=k;
          }
          dSumGamma+=dGamma_i;
          if(dQ>dMaxQ){
            dMaxQ=dQ;
            nMaxJIndex[nQ][i]=j;
            nMaxKIndex[nQ][i]=k;
          }
          if(dQ<dMinQ){
            dMinQ=dQ;
            nMinJIndex[nQ][i]=j;
            nMinKIndex[nQ][i]=k;
          }
          nMaxJIndex[nL_rad][i]=0;
          nMaxKIndex[nL_rad][i]=0;
          nMinJIndex[nL_rad][i]=0;
          nMinKIndex[nL_rad][i]=0;
          nMaxJIndex[nKE][i]=0;
          nMaxKIndex[nKE][i]=0;
          nMinJIndex[nKE][i]=0;
          nMinKIndex[nKE][i]=0;
          dSumQ+=dQ;
          nCount++;
        }
      }
      dAve[nL_rad][i]=dLSum_rad/dAreaSum*4.0*dPi*dRSq_ip1half;
      dAve[nL_con][i]=dLSum_con/dAreaSum*4.0*dPi*dRSq_ip1half;
      dU_i=(dGrid[nU0][i+1][0][0]+dGrid[nU0][i][0][0])*0.5;
      dAve[nKE][i]=0.5*dGrid[nDM][i][0][0]*dU_i*dU_i;
      dMax[nP][i]=dMaxP;
      dMin[nP][i]=dMinP;
      dAve[nP][i]=dSumP/double(nCount);
      dMax[nE][i]=dMaxE;
      dMin[nE][i]=dMinE;
      dAve[nE][i]=dSumE/double(nCount);
      dMax[nKappa][i]=dMaxKappa;
      dMin[nKappa][i]=dMinKappa;
      dAve[nKappa][i]=dSumKappa/double(nCount);
      dMax[nGamma][i]=dMaxGamma;
      dMin[nGamma][i]=dMinGamma;
      dAve[nGamma][i]=dSumGamma/double(nCount);
      dMax[nQ][i]=dMaxQ;
      dMin[nQ][i]=dMinQ;
      dAve[nQ][i]=dSumQ/double(nCount);
    }
  }
  else{//set P, Q, and KE
    
    //allocate space
    nGhostCellsX=1;
    if(nVarInfo[nD][0]==-1){/*all internal variables are cetnered quantities, will be the same as 
      the density*/
      nGhostCellsX=0;
    }
    nGhostCellsY=1;
    if(nVarInfo[nD][1]==-1){
      nGhostCellsY=0;
    }
    nGhostCellsZ=1;
    if(nVarInfo[nD][2]==-1){
      nGhostCellsZ=0;
    }
    double dP;
    double dQ;
    double dMaxP;
    double dMinP;
    double dSumP;
    double dMaxQ;
    double dMinQ;
    double dSumQ;
    double dQ0=0.0;
    double dQ1=0.0;
    double dQ2=0.0;
    double dRSq_i;
    double dA_ip1half;
    double dA_im1half;
    double dTheta_j;
    double dTheta_jp1half;
    double dTheta_jm1half;
    double dA_jp1half;
    double dA_jm1half;
    double dA_j;
    double dASq=dA*dA;
    double dC;
    double dDVDtThreshold;
    double dDVDt_mthreshold;
    double dDVDt;
    double dU_i;
    
    //set 1D part of the grid
    nSizeX1=nGhostCellsX*(nNum1DZones+nNumGhostCells);//may be need to +1 if only one proc and variable in interface centered
    if (nVarInfo[nD][0]==1&&nPeriodic[0]==0){
      nSizeX1=nGhostCellsX*(nNum1DZones+1+nNumGhostCells);
    }
    nSizeY=1;
    nSizeZ=1;
    for(i=0;i<nSizeX1;i++){//find average max, and min in 1D region
      
      //calculate P
      dP=dGrid[nD][i][0][0]*(dGamma-1.0)*dGrid[nE][i][0][0];
      
      //calculate Q
      dRSq_i=(dGrid[nR][i+1][0][0]+dGrid[nR][i][0][0])*0.5;
      dA_ip1half=dGrid[nR][i+1][0][0]*dGrid[nR][i+1][0][0];
      dA_im1half=dGrid[nR][i][0][0]*dGrid[nR][i][0][0];
      dC=sqrt(dGamma*dP/dGrid[nD][i][j][k]);
      dDVDtThreshold=dAVThreshold*dC;
      dDVDt=(dA_ip1half*dGrid[nU][i+1][j][k]
        -dA_im1half*dGrid[nU][i][j][k])/dRSq_i;
      if(dDVDt<-1.0*dDVDtThreshold){//being compressed
        dDVDt_mthreshold=dDVDt+dDVDtThreshold;
        dQ=dASq*dGrid[nD][i][j][k]*dDVDt_mthreshold*dDVDt_mthreshold;
      }
      else{
        dQ=0.0;
      }
      dU_i=(dGrid[nU0][i+1][0][0]+dGrid[nU0][i][0][0])*0.5;
      dAve[nKE][i]=0.5*dGrid[nDM][i][0][0]*dU_i*dU_i;
      dMax[nP][i]=dP;
      dMin[nP][i]=dP;
      dAve[nP][i]=dP;
      dMax[nQ][i]=dQ;
      dMin[nQ][i]=dQ;
      dAve[nQ][i]=dQ;
      nMaxJIndex[nP][i]=0;
      nMaxKIndex[nP][i]=0;
      nMinJIndex[nP][i]=0;
      nMinKIndex[nP][i]=0;
      nMaxJIndex[nQ][i]=0;
      nMaxKIndex[nQ][i]=0;
      nMinJIndex[nQ][i]=0;
      nMinKIndex[nQ][i]=0;
      nMaxJIndex[nKE][i]=0;
      nMaxKIndex[nKE][i]=0;
      nMinJIndex[nKE][i]=0;
      nMinKIndex[nKE][i]=0;
      
    }
    
    //set the rest of the grid
    nSizeX2=nSize[nD][0]+nGhostCellsX*2*nNumGhostCells;
    nSizeY=nSize[nD][1]+nGhostCellsY*2*nNumGhostCells;
    nSizeZ=nSize[nD][2]+nGhostCellsZ*2*nNumGhostCells;
    nStartY=nGhostCellsY*nNumGhostCells;
    nEndY=nSize[nD][1]+nStartY;
    nStartZ=nGhostCellsZ*nNumGhostCells;
    nEndZ=nSize[nD][2]+nStartZ;
    for(i=nSizeX1;i<nSizeX2;i++){
      dMaxP=-1.0*std::numeric_limits<double>::max();
      dMinP=std::numeric_limits<double>::max();
      dSumP=0.0;
      dMaxQ=-1.0*std::numeric_limits<double>::max();
      dMinQ=std::numeric_limits<double>::max();
      dSumQ=0.0;
      nCount=0;
      for(j=nStartY;j<nEndY;j++){
        dTheta_jp1half=dGrid[nTheta][0][j][0];
        if(j==0){
          dTheta_jm1half=dGrid[nTheta][0][j][0]-(dGrid[nTheta][0][j+1][0]-dGrid[nTheta][0][j][0]);
        }
        dTheta_j=(dTheta_jp1half+dTheta_jm1half)*0.5;
        dA_jp1half=sin(dTheta_jp1half);
        dA_jm1half=sin(dTheta_jm1half);;
        dA_j=sin(dTheta_j);
        for(k=nStartZ;k<nEndZ;k++){
          
          //calculate P
          dP=dGrid[nD][i][j][k]*(dGamma-1.0)*dGrid[nE][i][j][k];
        
          //calculate Q
          dC=sqrt(dGamma*dP/dGrid[nD][i][j][k]);
          dDVDtThreshold=dAVThreshold*dC;
          if(nNumDims>=1){
            dDVDt=(dA_ip1half*dGrid[nU][i+1][j][k]
              -dA_im1half*dGrid[nU][i][j][k])/dRSq_i;
            if(dDVDt<-1.0*dDVDtThreshold){//being compressed
              dDVDt_mthreshold=dDVDt+dDVDtThreshold;
              dQ0=dASq*dGrid[nD][i][j][k]*dDVDt_mthreshold*dDVDt_mthreshold;
            }
            else{
              dQ0=0.0;
            }
          }
          else if(nNumDims>=2){
            if(j==0){
              dDVDt=(dA_jp1half*dGrid[nV][i][j][k]
                -dA_jm1half*dGrid[nV][i][nSizeY-1][k])/dA_j;
            }
            else{
              dDVDt=(dA_jp1half*dGrid[nV][i][j][k]
                -dA_jm1half*dGrid[nV][i][j-1][k])/dA_j;
            }
            if(dDVDt<-1.0*dDVDtThreshold){//being compressed
              dDVDt_mthreshold=dDVDt+dDVDtThreshold;
              dQ1=dASq*dGrid[nD][i][j][k]
                *dDVDt_mthreshold*dDVDt_mthreshold;
            }
            else{
              dQ1=0.0;
            }
          }
          else if(nNumDims==3){
            if(k==0){
              dDVDt=(dGrid[nW][i][j][k]-dGrid[nW][i][j][nSizeZ-1]);
            }
            else{
              dDVDt=(dGrid[nW][i][j][k]-dGrid[nW][i][j][k-1]);
            }
            if(dDVDt<-1.0*dDVDtThreshold){//being compressed
              dDVDt_mthreshold=dDVDt+dDVDtThreshold;
              dQ2=dASq*dGrid[nD][i][j][k]*dDVDt_mthreshold*dDVDt_mthreshold;
            }
            else{
              dQ2=0.0;
            }
          }
          dQ=dQ0+dQ1+dQ2;
          
          if(dP>dMaxP){
            dMaxP=dP;
            nMaxJIndex[nP][i]=j;
            nMaxKIndex[nP][i]=k;
          }
          if(dP<dMinP){
            dMinP=dP;
            nMinJIndex[nP][i]=j;
            nMinKIndex[nP][i]=k;
          }
          dSumP+=dP;
          if(dQ>dMaxQ){
            dMaxQ=dQ;
            nMaxJIndex[nQ][i]=j;
            nMaxKIndex[nQ][i]=k;
          }
          if(dQ<dMinQ){
            dMinQ=dQ;
            nMinJIndex[nQ][i]=j;
            nMinKIndex[nQ][i]=k;
          }
          dSumQ+=dQ;
          
          nCount++;
        }
      }
      dU_i=(dGrid[nU0][i+1][0][0]+dGrid[nU0][i][0][0])*0.5;
      dAve[nKE][i]=0.5*dGrid[nDM][i][0][0]*dU_i*dU_i;
      dMax[nP][i]=dMaxP;
      dMin[nP][i]=dMinP;
      dAve[nP][i]=dSumP/double(nCount);
      dMax[nQ][i]=dMaxQ;
      dMin[nQ][i]=dMinQ;
      dAve[nQ][i]=dSumQ/double(nCount);
      nMaxJIndex[nKE][i]=0;
      nMaxKIndex[nKE][i]=0;
      nMinJIndex[nKE][i]=0;
      nMinKIndex[nKE][i]=0;
    }
  }
  
  //open output file
  std::string sFileNameOut=sFileName+"_pro.txt";
  std::ofstream ofFile;
  ofFile.open(sFileNameOut.c_str());
  if(!ofFile.good()){
    std::stringstream ssTemp;
    ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": output file \""
      <<sFileNameOut<<" didn't open properly\n";
    throw exception2(ssTemp.str(),INPUT);
  }
  
  //set double output precision
  ofFile.precision(nPrecisionAscii);
  if(bScientific){
    ofFile.unsetf(std::ios::fixed);
    ofFile.setf(std::ios::scientific);
  }
  else{
    ofFile.unsetf(std::ios::scientific);
    ofFile.setf(std::ios::fixed);
  }
  
  //write out header to profile file
  int nWidthOutputField=25;
  int nWidthIntOutputField=12;
  ofFile<<"time= "<<dTime<<" [s]"<<std::endl;
  ofFile<<std::setw(nWidthIntOutputField)<<"Zone_#(1)"
    <<std::setw(nWidthOutputField)<<"M_r_im1half[g](2)"
    <<std::setw(nWidthOutputField)<<"DM_r[g](3)"
    <<std::setw(nWidthOutputField)<<"ErrorDM_r(4)"
    <<std::setw(nWidthOutputField)<<"R_im1half[cm](5)"
    <<std::setw(nWidthOutputField)<<"R_ip1half[cm](6)"
    <<std::setw(nWidthOutputField)<<"D_ave[g/cm^3](7)"
    <<std::setw(nWidthOutputField)<<"D_max[g/cm^3](8)"
    <<std::setw(nWidthIntOutputField)<<"D_max_j(9)"
    <<std::setw(nWidthIntOutputField)<<"D_max_k(10)"
    <<std::setw(nWidthOutputField)<<"D_min[g/cm^3](11)"
    <<std::setw(nWidthIntOutputField)<<"D_min_j(12)"
    <<std::setw(nWidthIntOutputField)<<"D_min_k(13)"
    <<std::setw(nWidthOutputField)<<"U_ave_im1half[cm/s](14)"
    <<std::setw(nWidthOutputField)<<"U_max_im1half[cm/s](15)"
    <<std::setw(nWidthIntOutputField)<<"U_max_j(16)"
    <<std::setw(nWidthIntOutputField)<<"U_max_k(17)"
    <<std::setw(nWidthOutputField)<<"U_min_im1half[cm/s](18)"
    <<std::setw(nWidthIntOutputField)<<"U_min_j(19)"
    <<std::setw(nWidthIntOutputField)<<"U_min_k(20)"
    <<std::setw(nWidthOutputField)<<"U0[cm/s](21)"
    <<std::setw(nWidthOutputField)<<"V_ave[cm/s](22)"
    <<std::setw(nWidthOutputField)<<"V_max[cm/s](23)"
    <<std::setw(nWidthIntOutputField)<<"V_max_j(24)"
    <<std::setw(nWidthIntOutputField)<<"V_max_k(25)"
    <<std::setw(nWidthOutputField)<<"V_min[cm/s](26)"
    <<std::setw(nWidthIntOutputField)<<"V_min_j(27)"
    <<std::setw(nWidthIntOutputField)<<"V_min_k(28)"
    <<std::setw(nWidthOutputField)<<"W_ave[cm/s](29)"
    <<std::setw(nWidthOutputField)<<"W_max[cm/s](30)"
    <<std::setw(nWidthIntOutputField)<<"W_max_j(31)"
    <<std::setw(nWidthIntOutputField)<<"W_max_k(32)"
    <<std::setw(nWidthOutputField)<<"W_min[cm/s](33)"
    <<std::setw(nWidthIntOutputField)<<"W_min_j(34)"
    <<std::setw(nWidthIntOutputField)<<"W_min_k(35)"
    <<std::setw(nWidthOutputField)<<"Q[dynes/cm^2](36)"
    <<std::setw(nWidthOutputField)<<"Q_max[dynes/cm^2](37)"
    <<std::setw(nWidthOutputField)<<"Q_min[dynes/cm^2](38)"
    <<std::setw(nWidthOutputField)<<"E_ave[erg/g](39)"
    <<std::setw(nWidthOutputField)<<"E_max[erg/g](40)"
    <<std::setw(nWidthIntOutputField)<<"E_max_j(41)"
    <<std::setw(nWidthIntOutputField)<<"E_max_k(42)"
    <<std::setw(nWidthOutputField)<<"E_min[erg/g](43)"
    <<std::setw(nWidthIntOutputField)<<"E_min_j(44)"
    <<std::setw(nWidthIntOutputField)<<"E_min_k(45)"
    <<std::setw(nWidthOutputField)<<"T_ave[K](46)"
    <<std::setw(nWidthOutputField)<<"T_max[K](47)"
    <<std::setw(nWidthIntOutputField)<<"T_max_j(48)"
    <<std::setw(nWidthIntOutputField)<<"T_max_k(49)"
    <<std::setw(nWidthOutputField)<<"T_min[K](50)"
    <<std::setw(nWidthIntOutputField)<<"T_min_j(51)"
    <<std::setw(nWidthIntOutputField)<<"T_min_k(52)"
    <<std::setw(nWidthOutputField)<<"Kap_ave[cm^2/g](53)"
    <<std::setw(nWidthOutputField)<<"Kap_min[cm^2/g](54)"
    <<std::setw(nWidthOutputField)<<"Kap_max[cm^2/g](55)"
    <<std::setw(nWidthOutputField)<<"L_rad_im1half[L_sun](56)"
    <<std::setw(nWidthOutputField)<<"L_con_im1half[L_sun](57)"
    <<std::setw(nWidthOutputField)<<"KE[ergs](58)"
    <<std::setw(nWidthOutputField)<<"P_ave[dynes/cm^2](59)"
    <<std::setw(nWidthOutputField)<<"P_min[dynes/cm^2](60)"
    <<std::setw(nWidthOutputField)<<"P_max[dynes/cm^2](61)"
    <<std::setw(nWidthOutputField)<<"Gam_ave[na](62)"
    <<std::setw(nWidthOutputField)<<"Gam_min[na](63)"
    <<std::setw(nWidthOutputField)<<"Gam_max[na](64)"
    <<std::endl;
  
  //write out profile
  double dErrorDM_r;
  for(int i=0;i<nSizeGlobe[0]+2*nNumGhostCells;i++){
    
    //calculate mass error
    dErrorDM_r=(4.0/3.0*dPi*dGrid[nD][i][0][0]*(pow(dGrid[nR][i+1][0][0],3.0)
      -pow(dGrid[nR][i][0][0],3.0))-dGrid[nDM][i][0][0])/dGrid[nDM][i][0][0];
    
      nMaxJIndex[nP][i]=0;
      nMaxKIndex[nP][i]=0;
      nMinJIndex[nP][i]=0;
      nMinKIndex[nP][i]=0;
      
    ofFile<<std::setw(nWidthIntOutputField)<<i//1
      <<std::setw(nWidthOutputField)<<dGrid[nM][i][0][0]//2
      <<std::setw(nWidthOutputField)<<dGrid[nDM][i][0][0]//3
      <<std::setw(nWidthOutputField)<<dErrorDM_r//4
      <<std::setw(nWidthOutputField)<<dGrid[nR][i][0][0]//5
      <<std::setw(nWidthOutputField)<<dGrid[nR][i+1][0][0]//6
      <<std::setw(nWidthOutputField)<<dAve[nD][i]//7
      <<std::setw(nWidthOutputField)<<dMax[nD][i]//8
      <<std::setw(nWidthIntOutputField)<<nMaxJIndex[nD][i]//9
      <<std::setw(nWidthIntOutputField)<<nMaxKIndex[nD][i]//10
      <<std::setw(nWidthOutputField)<<dMin[nD][i]//11
      <<std::setw(nWidthIntOutputField)<<nMinJIndex[nD][i]//12
      <<std::setw(nWidthIntOutputField)<<nMinKIndex[nD][i]//13
      <<std::setw(nWidthOutputField)<<dAve[nU][i]//14
      <<std::setw(nWidthOutputField)<<dMax[nU][i]//15
      <<std::setw(nWidthIntOutputField)<<nMaxJIndex[nU][i]//16
      <<std::setw(nWidthIntOutputField)<<nMaxKIndex[nU][i]//17
      <<std::setw(nWidthOutputField)<<dMin[nU][i]//18
      <<std::setw(nWidthIntOutputField)<<nMinJIndex[nU][i]//19
      <<std::setw(nWidthIntOutputField)<<nMinKIndex[nU][i]//20
      <<std::setw(nWidthOutputField)<<dGrid[nU0][i][0][0];//21
    if(nNumDims>1){
      ofFile
        <<std::setw(nWidthOutputField)<<dAve[nV][i]//22
        <<std::setw(nWidthOutputField)<<dMax[nV][i]//23
        <<std::setw(nWidthIntOutputField)<<nMaxJIndex[nV][i]//24
        <<std::setw(nWidthIntOutputField)<<nMaxKIndex[nV][i]//25
        <<std::setw(nWidthOutputField)<<dMin[nV][i]//26
        <<std::setw(nWidthIntOutputField)<<nMinJIndex[nV][i]//27
        <<std::setw(nWidthIntOutputField)<<nMinKIndex[nV][i];//28
    }
    else{
      ofFile
        <<std::setw(nWidthOutputField)<<"-"//22
        <<std::setw(nWidthOutputField)<<"-"//23
        <<std::setw(nWidthIntOutputField)<<"-"//24
        <<std::setw(nWidthIntOutputField)<<"-"//25
        <<std::setw(nWidthOutputField)<<"-"//26
        <<std::setw(nWidthIntOutputField)<<"-"//27
        <<std::setw(nWidthIntOutputField)<<"-";//28
    }
    if(nNumDims>2){
      ofFile
        <<std::setw(nWidthOutputField)<<dAve[nW][i]//29
        <<std::setw(nWidthOutputField)<<dMax[nW][i]//30
        <<std::setw(nWidthIntOutputField)<<nMaxJIndex[nW][i]//31
        <<std::setw(nWidthIntOutputField)<<nMaxKIndex[nW][i]//32
        <<std::setw(nWidthOutputField)<<dMin[nW][i]//33
        <<std::setw(nWidthIntOutputField)<<nMinJIndex[nW][i]//34
        <<std::setw(nWidthIntOutputField)<<nMinKIndex[nW][i];//35
    }
    else{
      ofFile
        <<std::setw(nWidthOutputField)<<"-"//29
        <<std::setw(nWidthOutputField)<<"-"//30
        <<std::setw(nWidthIntOutputField)<<"-"//31
        <<std::setw(nWidthIntOutputField)<<"-"//32
        <<std::setw(nWidthOutputField)<<"-"//33
        <<std::setw(nWidthIntOutputField)<<"-"//34
        <<std::setw(nWidthIntOutputField)<<"-";//35
    }
    ofFile
      <<std::setw(nWidthOutputField)<<dAve[nQ][i]//36
      <<std::setw(nWidthOutputField)<<dMax[nQ][i]//37
      <<std::setw(nWidthOutputField)<<dMin[nQ][i];//38
    ofFile
      <<std::setw(nWidthOutputField)<<dAve[nE][i]//39
      <<std::setw(nWidthOutputField)<<dMax[nE][i]//40
      <<std::setw(nWidthIntOutputField)<<nMaxJIndex[nE][i]//41
      <<std::setw(nWidthIntOutputField)<<nMaxKIndex[nE][i]//42
      <<std::setw(nWidthOutputField)<<dMin[nE][i]//43
      <<std::setw(nWidthIntOutputField)<<nMinJIndex[nE][i]//44
      <<std::setw(nWidthIntOutputField)<<nMinKIndex[nE][i];//45
    if(nGammaLaw==0){
      ofFile
        <<std::setw(nWidthOutputField)<<"-"//46
        <<std::setw(nWidthOutputField)<<"-"//47
        <<std::setw(nWidthIntOutputField)<<"-"//48
        <<std::setw(nWidthIntOutputField)<<"-"//49
        <<std::setw(nWidthOutputField)<<"-"//50
        <<std::setw(nWidthIntOutputField)<<"-"//51
        <<std::setw(nWidthIntOutputField)<<"-"//52
        <<std::setw(nWidthOutputField)<<"-"//53
        <<std::setw(nWidthOutputField)<<"-"//54
        <<std::setw(nWidthOutputField)<<"-"//55
        <<std::setw(nWidthOutputField)<<"-"//56
        <<std::setw(nWidthOutputField)<<"-";//57
    }
    else{
      ofFile
        <<std::setw(nWidthOutputField)<<dAve[nT][i]//46
        <<std::setw(nWidthOutputField)<<dMax[nT][i]//47
        <<std::setw(nWidthIntOutputField)<<nMaxJIndex[nT][i]//48
        <<std::setw(nWidthIntOutputField)<<nMaxKIndex[nT][i]//49
        <<std::setw(nWidthOutputField)<<dMin[nT][i]//50
        <<std::setw(nWidthIntOutputField)<<nMinJIndex[nT][i]//51
        <<std::setw(nWidthIntOutputField)<<nMinKIndex[nT][i]//52
        <<std::setw(nWidthOutputField)<<dAve[nKappa][i]//53
        <<std::setw(nWidthOutputField)<<dMax[nKappa][i]//54
        <<std::setw(nWidthOutputField)<<dMin[nKappa][i];//55
      if(i!=0){
        ofFile
          <<std::setw(nWidthOutputField)<<dAve[nL_rad][i-1]/dLSun//56
          <<std::setw(nWidthOutputField)<<dAve[nL_con][i-1]/dLSun;//57
      }
      else{//luminosity not defined at inner interface
        ofFile
          <<std::setw(nWidthOutputField)<<"-"//56
          <<std::setw(nWidthOutputField)<<"-";//57
      }
    }
    ofFile
      <<std::setw(nWidthOutputField)<<dAve[nKE][i]//58
      <<std::setw(nWidthOutputField)<<dAve[nP][i]//59
      <<std::setw(nWidthOutputField)<<dMax[nP][i]//60
      <<std::setw(nWidthOutputField)<<dMin[nP][i]//61
      <<std::setw(nWidthOutputField)<<dAve[nGamma][i]//62
      <<std::setw(nWidthOutputField)<<dMax[nGamma][i]//63
      <<std::setw(nWidthOutputField)<<dMin[nGamma][i]//64
      <<std::endl;
  }
  ofFile
    <<std::setw(nWidthIntOutputField)<<(nSizeGlobe[0]+2*nNumGhostCells)//1
    <<std::setw(nWidthOutputField)<<dGrid[nM][nSizeGlobe[0]+2*nNumGhostCells][0][0]//2
    <<std::setw(nWidthOutputField)<<"-"//3
    <<std::setw(nWidthOutputField)<<"-"//4
    <<std::setw(nWidthOutputField)<<dGrid[nR][nSizeGlobe[0]+2*nNumGhostCells][0][0]//5
    <<std::setw(nWidthOutputField)<<"-"//6
    <<std::setw(nWidthOutputField)<<"-"//7
    <<std::setw(nWidthOutputField)<<"-"//8
    <<std::setw(nWidthIntOutputField)<<"-"//9
    <<std::setw(nWidthIntOutputField)<<"-"//10
    <<std::setw(nWidthOutputField)<<"-"//11
    <<std::setw(nWidthIntOutputField)<<"-"//12
    <<std::setw(nWidthIntOutputField)<<"-"//13
    <<std::setw(nWidthOutputField)<<dAve[nU][nSizeGlobe[0]+2*nNumGhostCells]//14
    <<std::setw(nWidthOutputField)<<dMax[nU][nSizeGlobe[0]+2*nNumGhostCells]//15
    <<std::setw(nWidthIntOutputField)<<nMaxJIndex[nU][i]//16
    <<std::setw(nWidthIntOutputField)<<nMaxKIndex[nU][i]//17
    <<std::setw(nWidthOutputField)<<dMin[nU][nSizeGlobe[0]+2*nNumGhostCells]//18
    <<std::setw(nWidthIntOutputField)<<nMinJIndex[nU][i]//19
    <<std::setw(nWidthIntOutputField)<<nMinKIndex[nU][i]//20
    <<std::setw(nWidthOutputField)<<dAve[nU0][nSizeGlobe[0]+2*nNumGhostCells]//21
    <<std::setw(nWidthOutputField)<<"-"//22
    <<std::setw(nWidthOutputField)<<"-"//23
    <<std::setw(nWidthIntOutputField)<<"-"//24
    <<std::setw(nWidthIntOutputField)<<"-"//25
    <<std::setw(nWidthOutputField)<<"-"//26
    <<std::setw(nWidthIntOutputField)<<"-"//27
    <<std::setw(nWidthIntOutputField)<<"-"//28
    <<std::setw(nWidthOutputField)<<"-"//29
    <<std::setw(nWidthOutputField)<<"-"//30
    <<std::setw(nWidthIntOutputField)<<"-"//31
    <<std::setw(nWidthIntOutputField)<<"-"//32
    <<std::setw(nWidthOutputField)<<"-"//33
    <<std::setw(nWidthIntOutputField)<<"-"//34
    <<std::setw(nWidthIntOutputField)<<"-"//35
    <<std::setw(nWidthOutputField)<<"-"//36
    <<std::setw(nWidthOutputField)<<"-"//37
    <<std::setw(nWidthOutputField)<<"-"//38
    <<std::setw(nWidthOutputField)<<"-"//39
    <<std::setw(nWidthOutputField)<<"-"//40
    <<std::setw(nWidthIntOutputField)<<"-"//41
    <<std::setw(nWidthIntOutputField)<<"-"//42
    <<std::setw(nWidthOutputField)<<"-"//43
    <<std::setw(nWidthIntOutputField)<<"-"//44
    <<std::setw(nWidthIntOutputField)<<"-"//45
    <<std::setw(nWidthOutputField)<<"-"//46
    <<std::setw(nWidthOutputField)<<"-"//47
    <<std::setw(nWidthIntOutputField)<<"-"//48
    <<std::setw(nWidthIntOutputField)<<"-"//49
    <<std::setw(nWidthOutputField)<<"-"//50
    <<std::setw(nWidthIntOutputField)<<"-"//51
    <<std::setw(nWidthIntOutputField)<<"-"//52
    <<std::setw(nWidthOutputField)<<"-"//53
    <<std::setw(nWidthOutputField)<<"-"//54
    <<std::setw(nWidthOutputField)<<"-"//55
    <<std::setw(nWidthOutputField)<<dAve[nL_rad][nSizeGlobe[0]+2*nNumGhostCells-1]/dLSun//56
    <<std::setw(nWidthOutputField)<<dAve[nL_con][nSizeGlobe[0]+2*nNumGhostCells-1]/dLSun//57
    <<std::setw(nWidthOutputField)<<"-"//58
    <<std::setw(nWidthOutputField)<<"-"//59
    <<std::setw(nWidthOutputField)<<"-"//60
    <<std::setw(nWidthOutputField)<<"-"//61
    <<std::setw(nWidthOutputField)<<"-"//62
    <<std::setw(nWidthOutputField)<<"-"//63
    <<std::setw(nWidthOutputField)<<"-"//64
    <<std::endl;
  
  ofFile.close();
  //also need to delete dGrid
  for(int n=0;n<nNumVars;n++){
    delete [] nSize[n];
    delete [] nVarInfo[n];
  }
  delete [] nSize;
  delete [] nVarInfo;
}
void fpSignalHandler(int nSig){
  std::stringstream ssTemp;
  ssTemp<<"Floating point signal "<<nSig<<" detected. Aborting program\n";
  throw exception2(ssTemp.str(),CALCULATION);
}
void make2DSlice(std::string sFileName,int nPlane,int nPlaneIndex){//updated
  
  int nWidthOutputField=25;
  
  //open input file
  if(sFileName.size()==0){
    std::stringstream ssTemp;
    ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
      <<": no input file specified\n";
    throw exception2(ssTemp.str(),INPUT);
  }
  std::ifstream ifFile;
  ifFile.open(sFileName.c_str(),std::ios::binary);
  if(!ifFile.good()){
    std::stringstream ssTemp;
    ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": input file \""
      <<sFileName<<"\" didn't open properly\n";
    throw exception2(ssTemp.str(),INPUT);
  }
  
  //check that it is a binary file
  char cTemp;
  ifFile.read((char*)(&cTemp),sizeof(char));
  if(cTemp!='b'){
    std::stringstream ssTemp;
    ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": input file \""
      <<sFileName<<"\" isn't a binary file.\n";
    throw exception2(ssTemp.str(),INPUT);
  }
  
  //check that it is the correct version
  int nTemp;
  ifFile.read((char*)(&nTemp),sizeof(int));
  if(nTemp!=nDumpFileVersion){
    std::stringstream ssTemp;
    ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": inpput file \""
      <<sFileName<<"\" version \""<<nTemp
      <<"\" isn't the supported version \""<<nDumpFileVersion<<"\".\n";
    throw exception2(ssTemp.str(),INPUT);
  }
  
  //read in binary input file and write out in averaged profiles
  
  //read in time
  double dTime;
  ifFile.read((char*)(&dTime),sizeof(double));
  
  //read in the time step index
  int nTimeStepIndex;
  ifFile.read((char*)(&nTimeStepIndex),sizeof(int));
  
  //read in timestep
  double dTimeStep1;
  ifFile.read((char*)(&dTimeStep1),sizeof(double));
  
  //read in timestep
  double dTimeStep2;
  ifFile.read((char*)(&dTimeStep2),sizeof(double));
  
  //read in alpha
  double dAlpha;
  ifFile.read((char*)(&dAlpha),sizeof(double));
  
  //read in gamma law
  int nGammaLaw;
  ifFile.read((char*)(&nGammaLaw),sizeof(int));
  
  double dGamma;
  std::string sEOSTable;
  eos eosTable;
  if(nGammaLaw==0){
    ifFile.read((char*)(&dGamma),sizeof(double));
  }
  else{
    char *cBuffer=new char[nGammaLaw+1];
    ifFile.read(cBuffer,nGammaLaw*sizeof(char));
    cBuffer[nGammaLaw]='\0';
    sEOSTable=cBuffer;
    delete [] cBuffer;
    eosTable.readBin(sEOSTable);
  }
  
  //read in artificial viscosity
  double dA;
  ifFile.read((char*)(&dA),sizeof(double));
  double dASq=dA*dA;
  
  //read in artificial viscosity threshold
  double dAVThreshold;
  ifFile.read((char*)(&dAVThreshold),sizeof(double));
  
  //read in global grid size
  int nSizeGlobe[3];
  ifFile.read((char*)(nSizeGlobe),3*sizeof(int));
  
  //read in periodicity
  int nPeriodic[3];
  ifFile.read((char*)(nPeriodic),3*sizeof(int));
  
  //read in number of 1D Zones
  int nNum1DZones;
  ifFile.read((char*)(&nNum1DZones),sizeof(int));
  
  //read in number of ghostcells
  int nNumGhostCells;
  ifFile.read((char*)(&nNumGhostCells),sizeof(int));
  
  //read in number of grid variables
  int nNumVars;
  ifFile.read((char*)(&nNumVars),sizeof(int));
  
  //get variable info, and set grid sizes
  int **nSize=new int*[nNumVars];
  int **nVarInfo=new int*[nNumVars];
  for(int n=0;n<nNumVars;n++){
    nSize[n]=new int[3];
    nVarInfo[n]=new int[3];
    ifFile.read((char*)(nVarInfo[n]),(4)*sizeof(int));
    for(int l=0;l<3;l++){
      if(nSizeGlobe[l]==1){
        nVarInfo[n][l]=-1;
      }
      if(nVarInfo[n][l]==-1){//variable not defined in direction l
        nSize[n][l]=1;
      }
      else if(nVarInfo[n][l]==1&&l==0){//interface variable
        nSize[n][l]=nSizeGlobe[l]+1;
      }
      else{
        nSize[n][l]=nSizeGlobe[l];
      }
    }
  }
  
  //set global grid sizes
  int nSize0=nSizeGlobe[0]+1+2*nNumGhostCells;
  if(nSizeGlobe[0]==1){
    nSize0=nSizeGlobe[0]+1;//don't need ghost cells if grid not defined in direction l
  }
  int nSize1=nSizeGlobe[1]+1+2*nNumGhostCells;
  if(nSizeGlobe[1]==1){
    nSize1=nSizeGlobe[1];//don't need ghost cells if grid not defined in direction l
  }
  int nSize2=nSizeGlobe[2]+1+2*nNumGhostCells;
  if(nSizeGlobe[2]==1){
    nSize2=nSizeGlobe[2]+1;//don't need ghost cells if grid not defined in direction l
  }
  
  //figure out number of dimensions
  int nNumDims=0;
  if(nSizeGlobe[0]>1){
    nNumDims++;
  }
  if(nSizeGlobe[1]>1){
    nNumDims++;
  }
  if(nSizeGlobe[2]>1){
    nNumDims++;
  }
  
  //read in grid
  double ****dGrid=new double***[nNumVars];
  for(int n=0;n<nNumVars;n++){
    
    int nGhostCellsX=1;
    if(nVarInfo[n][0]==-1){
      nGhostCellsX=0;
    }
    int nGhostCellsY=1;
    if(nVarInfo[n][1]==-1){
      nGhostCellsY=0;
    }
    int nGhostCellsZ=1;
    if(nVarInfo[n][2]==-1){
      nGhostCellsZ=0;
    }
    
    dGrid[n]=new double**[nSize[n][0]+nGhostCellsX*2*nNumGhostCells];
    
    //read in 1D part of the grid
    int nSizeX1=nGhostCellsX*(nNum1DZones+nNumGhostCells);//may be need to +1 if only one proc and variable in interface centered
    if (nVarInfo[n][0]==1&&nPeriodic[0]==0){
      nSizeX1=nGhostCellsX*(nNum1DZones+1+nNumGhostCells);
    }
    int nSizeY=1;
    int nSizeZ=1;
    for(int i=0;i<nSizeX1;i++){
      dGrid[n][i]=new double*[nSizeY];
      for(int j=0;j<nSizeY;j++){
        dGrid[n][i][j]=new double[nSizeZ];
        ifFile.read((char*)(dGrid[n][i][j]),nSizeZ*sizeof(double));
      }
    }
    
    //read in the rest of the grid
    int nSizeX2=nSize[n][0]+nGhostCellsX*2*nNumGhostCells;
    nSizeY=nSize[n][1]+nGhostCellsY*2*nNumGhostCells;
    nSizeZ=nSize[n][2]+nGhostCellsZ*2*nNumGhostCells;
    for(int i=nSizeX1;i<nSizeX2;i++){
      dGrid[n][i]=new double*[nSizeY];
      for(int j=0;j<nSizeY;j++){
        if(ifFile.eof()){
          std::stringstream ssTemp;
          ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
            <<": reached end of file sooner than expected\n";
          throw exception2(ssTemp.str(),INPUT);
        }
        dGrid[n][i][j]=new double[nSizeZ];
        ifFile.read((char*)(dGrid[n][i][j]),(nSizeZ)*sizeof(double));
      }
    }
  }
  ifFile.close();
  
  //set variable indices
  if(nGammaLaw==0){//using gamma law gas
    if(nNumDims==1){
      nM=0;
      nTheta=-1;
      nPhi=-1;
      nDM=1;
      nR=2;
      nD=3;
      nU=4;
      nU0=5;
      nV=-1;
      nW=-1;
      nE=6;
      nT=-1;
    }
    else if(nNumDims==2){
      nM=0;
      nTheta=1;
      nPhi=-1;
      nDM=2;
      nR=3;
      nD=4;
      nU=5;
      nU0=6;
      nV=7;
      nW=-1;
      nE=8;
      nT=-1;
    }
    else if(nNumDims==3){
      nM=0;
      nTheta=1;
      nPhi=2;
      nDM=3;
      nR=4;
      nD=5;
      nU=6;
      nU0=7;
      nV=8;
      nW=9;
      nE=10;
      nT=-1;
    }
  }
  else{//using a tabulated equaiton of state
    if(nNumDims==1){
      nM=0;
      nTheta=-1;
      nPhi=-1;
      nDM=1;
      nR=2;
      nD=3;
      nU=4;
      nU0=5;
      nV=-1;
      nW=-1;
      nE=-1;
      nT=6;
    }
    else if(nNumDims==2){
      nM=0;
      nTheta=1;
      nPhi=-1;
      nDM=2;
      nR=3;
      nD=4;
      nU=5;
      nU0=6;
      nV=7;
      nW=-1;
      nE=-1;
      nT=8;
    }
    else if(nNumDims==3){
      nM=0;
      nTheta=1;
      nPhi=2;
      nDM=3;
      nR=4;
      nD=5;
      nU=6;
      nU0=7;
      nV=8;
      nW=9;
      nE=-1;
      nT=10;
    }
  }
  
  //check that slice index is within the model
  if (nPlane==0){//r-theta
    if(nPlaneIndex>nSize[nD][2]+2*nNumGhostCells-1){
      std::stringstream ssTemp;
      ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": r-theta plane index "<<nPlaneIndex
        <<" is larger than size of input model in phi-direction of "
        <<(nSize[nD][2]+2*nNumGhostCells-1)<<std::endl;
      throw exception2(ssTemp.str(),INPUT);
    }
    else if(nPlaneIndex>0 && nNumDims==2){
      std::stringstream ssTemp;
      ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": r-theta plane index "<<nPlaneIndex
        <<" is larger than size of input model in phi-direction of "
        <<(nSize[nD][2]-1)<<std::endl;
      throw exception2(ssTemp.str(),INPUT);
    }
  }
  else if(nPlane==1){//theta-phi
    if(nPlaneIndex>nSize[nD][0]+2*nNumGhostCells-1){
      std::stringstream ssTemp;
      ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": theta-phi plane index "<<nPlaneIndex
        <<" is larger than size of input model in r-direction of "
        <<(nSize[nD][0]+2*nNumGhostCells-1)<<std::endl;
      throw exception2(ssTemp.str(),INPUT);
    }
    if(nPlaneIndex<nNum1DZones-1){
      std::stringstream ssTemp;
      ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": theta-phi plane index "<<nPlaneIndex
        <<" is inside the 1D region of input model, 3D region begins at radial zone "<<nNum1DZones
        <<std::endl;
      throw exception2(ssTemp.str(),INPUT);
    }
  }
  else if(nPlane==2){//r-phi
    if(nPlaneIndex>nSize[nD][1]+2*nNumGhostCells-1){
      std::stringstream ssTemp;
      ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": r-phi plane index "<<nPlaneIndex
        <<" is larger than size of input model in theta-direction of "
        <<(nSize[nD][1]+2*nNumGhostCells-1)<<std::endl;
      throw exception2(ssTemp.str(),INPUT);
    }
  }
  
  //open output file
  std::stringstream sFileNameOut;
  if(nPlane==0){//r-theta plane
    if(nPlaneIndex>=0&&nPlaneIndex<nSize1){
      sFileNameOut<<sFileName<<"_2Dk="<<nPlaneIndex<<".txt";
    }
    else{
      std::stringstream ssTemp;
      ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": nPlaneIndex="<<nPlaneIndex
        <<" is outside theta zoning\n";
      throw exception2(ssTemp.str(),SYNTAX);
    }
  }
  else if(nPlane==1){//theta-phi plane
    if(nPlaneIndex>nNum1DZones+nNumGhostCells&&nPlaneIndex<nSize0){
      sFileNameOut<<sFileName<<"_2Di="<<nPlaneIndex<<".txt";
    }
    else{
      std::stringstream ssTemp;
      ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": nPlaneIndex="<<nPlaneIndex
        <<" is inside 1D radial only region or outside of radial zoning\n"
        <<" can not make theta-phi plane slice\n";
      throw exception2(ssTemp.str(),SYNTAX);
    }
  }
  else if(nPlane==2){//phi-r plane
    if(nPlaneIndex>=0&&nPlaneIndex<nSize2){
      sFileNameOut<<sFileName<<"_2Dj="<<nPlaneIndex<<".txt";
    }
    else{
      std::stringstream ssTemp;
      ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": nPlaneIndex="<<nPlaneIndex
        <<" is outside phi zoning\n";
      throw exception2(ssTemp.str(),SYNTAX);
    }
  }
  else{
    std::stringstream ssTemp;
    ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": unknown plane type\n";
    throw exception2(ssTemp.str(),SYNTAX);
  }
  std::ofstream ofFile;
  ofFile.open(sFileNameOut.str().c_str());
  if(!ofFile.good()){
    std::stringstream ssTemp;
    ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": output file \""
      <<sFileNameOut<<" didn't open properly\n";
    throw exception2(ssTemp.str(),INPUT);
  }
  
  //set double output precision
  ofFile.precision(nPrecisionAscii);
  if(bScientific){
    ofFile.unsetf(std::ios::fixed);
    ofFile.setf(std::ios::scientific);
  }
  else{
    ofFile.unsetf(std::ios::scientific);
    ofFile.setf(std::ios::fixed);
  }
  
  //write header to file
  if(nPlane==0){//r-theta plane
    ofFile<<"rt"<<std::endl;
  }
  else if(nPlane==1){//theta-phi plane
    ofFile<<"tp"<<std::endl;
  }
  else if(nPlane==2){//phi-r plane
    ofFile<<"rp"<<std::endl;
  }
  ofFile<<"t[s] "<<dTime<<" ";
  if(nGammaLaw==0){
    ofFile<<"0 "<<dGamma;
  }
  else{
    ofFile<<sEOSTable.size()<<" "<<sEOSTable;
  }
  ofFile<<std::endl;
  
  //write out slice
  double dP;
  double dE;
  double dKappa;
  double dQ;
  double dQ0;
  double dQ1;
  double dQ2;
  double dR_i;
  double dRSq_i;
  double dA_ip1half;
  double dA_im1half;
  double dRSq_ip1half;
  double dC;
  double dDVDtThreshold;
  double dDVDt;
  double dDVDt_mthreshold;
  double dTheta_jp1half;
  double dTheta_jm1half;
  double dTheta_j;
  double dA_jp1half;
  double dA_jm1half;
  double dA_j;
  if(nPlane==0){//r-theta
    
    //write out cooridnate variables
    //i
    ofFile<<"im1half(0) ";
    for( int i=0;i<nSize[nR][0]+2*nNumGhostCells;i++){
      ofFile<<i<<" ";
    }
    ofFile<<std::endl;
    
    //M_r
    ofFile<<"M_r_im1half[g](1) ";
    for( int i=0;i<nSize[nR][0]+2*nNumGhostCells;i++){
      ofFile<<dGrid[nM][i][0][0]<<" ";
    }
    ofFile<<std::endl;
    
    //R
    ofFile<<"R_im1half[cm](2) ";
    for( int i=0;i<nSize[nR][0]+2*nNumGhostCells;i++){
      ofFile<<dGrid[nR][i][0][0]<<" ";
    }
    ofFile<<std::endl;
    
    //j
    ofFile<<"jm1half(3) ";
    for( int j=0;j<nSize[nD][1]+1+2*nNumGhostCells;j++){//add an extra since it is an interface
      ofFile<<j<<" ";
    }
    ofFile<<std::endl;
    
    //theta
    int nInterFaceY=0;
    if(nPeriodic[1]==0){
      nInterFaceY=1;
    }
    ofFile<<"theta_jm1half[rad](4) ";
    if(nPeriodic[1]==1){/*write out inner interface if periodic, if not periodic, it is already 
      included*/
      double dInnerTheta=dGrid[nTheta][0][0][0]-(dGrid[nTheta][0][nSize[nD][1]+nNumGhostCells-2][0]
        -dGrid[nTheta][0][nSize[nD][1]+nNumGhostCells-3][0]);
      ofFile<<dInnerTheta<<" ";
     
    }
    for( int j=0;j<nSize[nD][1]+nInterFaceY+2*nNumGhostCells;j++){
      ofFile<<dGrid[nTheta][0][j][0]<<" ";
    }
    ofFile<<std::endl;
    
    //k
    if(nNumDims>2){
      ofFile<<"km1half(5) "<<nPlaneIndex<<" "<<nPlaneIndex+1<<std::endl;
    }
    else{
      ofFile<<"km1half(5) "<<0<<" "<<1<<std::endl;
    }
    
    //phi
    if(nNumDims>2){
      ofFile<<"phi_km1half[rad](6) "<<dGrid[nPhi][0][0][nPlaneIndex]<<" ";
      if(nPlaneIndex==nSize[nPhi][2]+2*nNumGhostCells-1){//if in last zone, need to do something to get outter phi
        ofFile<<dGrid[nPhi][0][0][nPlaneIndex]+(dGrid[nPhi][0][0][nPlaneIndex]
          -dGrid[nPhi][0][0][nPlaneIndex-1])<<std::endl;
      }
      else{
        ofFile<<dGrid[nPhi][0][0][nPlaneIndex+1]<<std::endl;
      }
    }
    else{
      ofFile<<"phi_km1half[rad](6) "<<0.0<<" "<<0.0<<std::endl;
    }
    
    //write out header for 2D data
    ofFile
      <<std::setw(nWidthOutputField)<<"U_im1halfjk[cm/s](7)"
      <<std::setw(nWidthOutputField)<<"U0_im1half[cm/s](8)"
      <<std::setw(nWidthOutputField)<<"V_ijm1halfk[cm/s](9)"
      <<std::setw(nWidthOutputField)<<"W_ijkm1half[cm/s](10)"
      <<std::setw(nWidthOutputField)<<"D_ijk[g/cm^3](11)"<<std::setw(nWidthOutputField)
      <<"D_rel_dif_hor_ave(12)"
      <<std::setw(nWidthOutputField)<<"E_ijk[erg/g](13)"<<std::setw(nWidthOutputField)
      <<"E_rel_dif_hor_ave(14)"
      <<std::setw(nWidthOutputField)<<"T_ijk[K](15)"<<std::setw(nWidthOutputField)
      <<"T_rel_dif_hor_ave(16)"
      <<std::setw(nWidthOutputField)<<"P_ijk[dynes/cm^2](17)"<<std::setw(nWidthOutputField)
      <<"P_rel_dif_hor_ave(18)"
      <<std::setw(nWidthOutputField)<<"Q_ijk[dynes/cm^2](19)"<<std::setw(nWidthOutputField)
      <<"Q_rel_dif_hor_ave(20)"
      <<std::setw(nWidthOutputField)<<"Kap_ij[cm^2/g](21)"<<std::setw(nWidthOutputField)
      <<"Kap_rel_dif_hor_ave(22)"
      <<std::setw(nWidthOutputField)<<"Gam_ijk[na](23)"<<std::setw(nWidthOutputField)
      <<"Gam_rel_dif_hor_ave(24)"
      <<std::endl;
    
    //copy 1D region to 2D grid
    int nSizeX1=nNum1DZones+nNumGhostCells;
    int nSizeY2=nSize[nD][1]+2*nNumGhostCells;
    int nSizeZ=nSize[nD][2]+2*nNumGhostCells;
    for(int i=0;i<nSizeX1;i++){
      dR_i=(dGrid[nR][i+1][0][0]+dGrid[nR][i][0][0])*0.5;
      dRSq_ip1half=dGrid[nR][i+1][0][0]*dGrid[nR][i+1][0][0];
      dRSq_i=dR_i*dR_i;
      dA_ip1half=dGrid[nR][i+1][0][0]*dGrid[nR][i+1][0][0];
      dA_im1half=dGrid[nR][i][0][0]*dGrid[nR][i][0][0];
      for(int j=0;j<nSizeY2;j++){
        
        ofFile
          <<std::setw(nWidthOutputField)<<dGrid[nU][i][0][0]//0
          <<std::setw(nWidthOutputField)<<dGrid[nU0][i][0][0]//1
          <<std::setw(nWidthOutputField)<<0.0;//2
        if(nW==-1){
          ofFile<<std::setw(nWidthOutputField)<<"-";//2
        }
        ofFile
          <<std::setw(nWidthOutputField)<<0.0//3
          <<std::setw(nWidthOutputField)<<dGrid[nD][i][0][0]<<std::setw(nWidthOutputField)<<0.0;//4,5
        
        if(nGammaLaw!=0){//set P,E,kappa,gamma, Q, and L
          
          //get P, E, kappa, and gamma
          eosTable.getPEKappaGamma(dGrid[nT][i][0][0],dGrid[nD][i][0][0],dP,dE,dKappa,dGamma);
          
          //calculate Q
          dC=sqrt(dGamma*dP/dGrid[nD][i][0][0]);
          dDVDtThreshold=dAVThreshold*dC;
          dDVDt=(dA_ip1half*dGrid[nU][i+1][0][0]
            -dA_im1half*dGrid[nU][i][0][0])/dRSq_i;
          if(dDVDt<-1.0*dDVDtThreshold){//being compressed
            dDVDt_mthreshold=dDVDt+dDVDtThreshold;
            dQ=dASq*dGrid[nD][i][0][0]*dDVDt_mthreshold*dDVDt_mthreshold;
          }
          else{
            dQ=0.0;
          }
          
          //print them out
          ofFile
            <<std::setw(nWidthOutputField)<<dE<<std::setw(nWidthOutputField)<<0.0//6,7
            <<std::setw(nWidthOutputField)<<dGrid[nT][i][0][0]<<std::setw(nWidthOutputField)<<0.0//8,9
            <<std::setw(nWidthOutputField)<<dP<<std::setw(nWidthOutputField)<<0.0//10,11
            <<std::setw(nWidthOutputField)<<dQ<<std::setw(nWidthOutputField)<<0.0//12,13
            <<std::setw(nWidthOutputField)<<dKappa<<std::setw(nWidthOutputField)<<0.0//14,15
            <<std::setw(nWidthOutputField)<<dGamma<<std::setw(nWidthOutputField)<<0.0;//16,17
          
        }
        else{//set P and Q
          
          dP=dGrid[nD][i][0][0]*(dGamma-1.0)*dGrid[nE][i][0][0];
          
          
          //calculate Q
          dR_i=(dGrid[nR][i+1][0][0]+dGrid[nR][i][0][0])*0.5;
          dRSq_i=dR_i*dR_i;
          dA_ip1half=dGrid[nR][i+1][0][0]*dGrid[nR][i+1][0][0];
          dA_im1half=dGrid[nR][i][0][0]*dGrid[nR][i][0][0];
          dC=sqrt(dGamma*dP/dGrid[nD][i][0][0]);
          dDVDtThreshold=dAVThreshold*dC;
          dDVDt=(dA_ip1half*dGrid[nU][i+1][0][0]
            -dA_im1half*dGrid[nU][i][0][0])/dRSq_i;
          if(dDVDt<-1.0*dDVDtThreshold){//being compressed
            dDVDt_mthreshold=dDVDt+dDVDtThreshold;
            dQ=dASq*dGrid[nD][i][0][0]*dDVDt_mthreshold*dDVDt_mthreshold;
          }
          else{
            dQ=0.0;
          }
          
          //print them out
          ofFile
            <<std::setw(nWidthOutputField)<<dGrid[nE][i][0][0]<<std::setw(nWidthOutputField)<<0.0//6,7
            <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)<<"-"//8,9
            <<std::setw(nWidthOutputField)<<dP<<std::setw(nWidthOutputField)<<0.0//10,11
            <<std::setw(nWidthOutputField)<<dQ<<std::setw(nWidthOutputField)<<0.0//12,13
            <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)<<"-"//14,15
            <<std::setw(nWidthOutputField)<<dGamma<<std::setw(nWidthOutputField)<<0.0;//16,17
        }
        ofFile<<std::endl;
      }
    ofFile
      <<std::setw(nWidthOutputField)<<"-"
      <<std::setw(nWidthOutputField)<<"-"
      <<std::setw(nWidthOutputField)<<dGrid[nV][i][0][0]
      <<std::setw(nWidthOutputField)<<"-"
      <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
      <<"-"
      <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
      <<"-"
      <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
      <<"-"
      <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
      <<"-"
      <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
      <<"-"
      <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
      <<"-"
      <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
      <<"-"
      <<std::endl;
    }
    
    //3D region
    int nSizeX2=nSize[nD][0]+2*nNumGhostCells;
    for(int i=nSizeX1;i<nSizeX2;i++){
      
      dR_i=(dGrid[nR][i+1][0][0]+dGrid[nR][i][0][0])*0.5;
      dRSq_ip1half=dGrid[nR][i+1][0][0]*dGrid[nR][i+1][0][0];
      dRSq_i=dR_i*dR_i;
      dA_ip1half=dGrid[nR][i+1][0][0]*dGrid[nR][i+1][0][0];
      dA_im1half=dGrid[nR][i][0][0]*dGrid[nR][i][0][0];
      
      //calculate horizontal average of various quantities
      double dDAve=0.0;
      double dEAve=0.0;
      double dTAve=0.0;
      double dPAve=0.0;
      double dQAve=0.0;
      double dKappaAve=0.0;
      double dGammaAve=0.0;
      int nCount=0;
      if(nGammaLaw!=0){//set P,E,kappa,gamma, Q, and L
        
        for(int j=0;j<nSizeY2;j++){
          
          dTheta_jp1half=dGrid[nTheta][0][j][0];
          if(j==0){
            dTheta_jm1half=dGrid[nTheta][0][j][0]-(dGrid[nTheta][0][j+1][0]-dGrid[nTheta][0][j][0]);
          }
          else{
            dTheta_jm1half=dGrid[nTheta][0][j-1][0];
          }
          dTheta_j=(dTheta_jp1half+dTheta_jm1half)*0.5;
          dA_jp1half=sin(dTheta_jp1half);
          dA_jm1half=sin(dTheta_jm1half);
          dA_j=sin(dTheta_j);
          
          //get P, E, kappa, and gamma
          eosTable.getPEKappaGamma(dGrid[nT][i][j][nPlaneIndex],dGrid[nD][i][j][nPlaneIndex],dP,dE
            ,dKappa,dGamma);
          
          //calculate Q
          dC=sqrt(dGamma*dP/dGrid[nD][i][j][nPlaneIndex]);
          dDVDtThreshold=dAVThreshold*dC;
          
          //Q0
          if(nNumDims>=1){
            if(i==nSizeX1){
              dDVDt=(dA_ip1half*dGrid[nU][i+1][j][nPlaneIndex]
                -dA_im1half*dGrid[nU][i][0][0])/dRSq_i;
            }
            else{
              dDVDt=(dA_ip1half*dGrid[nU][i+1][j][nPlaneIndex]
                -dA_im1half*dGrid[nU][i][j][nPlaneIndex])/dRSq_i;
            }
            if(dDVDt<-1.0*dDVDtThreshold){//being compressed
              dDVDt_mthreshold=dDVDt+dDVDtThreshold;
              dQ0=dASq*dGrid[nD][i][j][nPlaneIndex]*dDVDt_mthreshold*dDVDt_mthreshold;
            }
            else{
              dQ0=0.0;
            }
          }
          
          //Q1
          if(nNumDims>=2){
            if(j==0){
              dDVDt=(dA_jp1half*dGrid[nV][i][j][nPlaneIndex]
                -dA_jm1half*dGrid[nV][i][nSizeY2-1][nPlaneIndex])/dA_j;
            }
            else{
              dDVDt=(dA_jp1half*dGrid[nV][i][j][nPlaneIndex]
                -dA_jm1half*dGrid[nV][i][j-1][nPlaneIndex])/dA_j;
            }
            if(dDVDt<-1.0*dDVDtThreshold){//being compressed
              dDVDt_mthreshold=dDVDt+dDVDtThreshold;
              dQ1=dASq*dGrid[nD][i][j][nPlaneIndex]
                *dDVDt_mthreshold*dDVDt_mthreshold;
            }
            else{
              dQ1=0.0;
            }
          }
          
          //Q2
          if(nNumDims==3){
            if(nPlaneIndex==0){
              dDVDt=(dGrid[nW][i][j][nPlaneIndex]-dGrid[nW][i][j][nSizeZ-1]);
            }
            else{
              dDVDt=(dGrid[nW][i][j][nPlaneIndex]-dGrid[nW][i][j][nPlaneIndex-1]);
            }
            if(dDVDt<-1.0*dDVDtThreshold){//being compressed
              dDVDt_mthreshold=dDVDt+dDVDtThreshold;
              dQ2=dASq*dGrid[nD][i][j][nPlaneIndex]*dDVDt_mthreshold*dDVDt_mthreshold;
            }
            else{
              dQ2=0.0;
            }
          }
          dQ=dQ0+dQ1+dQ2;
          
          dDAve+=dGrid[nD][i][j][nPlaneIndex];
          dEAve+=dE;
          dTAve+=dGrid[nT][i][j][nPlaneIndex];
          dPAve+=dP;
          dQAve+=dQ;
          dKappaAve+=dKappa;
          dGammaAve+=dGamma;
          nCount++;
        }
        dDAve=dDAve/double(nCount);
        dEAve=dEAve/double(nCount);
        dTAve=dTAve/double(nCount);
        dPAve=dPAve/double(nCount);
        dQAve=dQAve/double(nCount);
        dKappaAve=dKappaAve/double(nCount);
        dGammaAve=dGammaAve/double(nCount);
      }
      else{//set P and Q
        
        for(int j=0;j<nSizeY2;j++){
          
          if(nNumDims>1){
            dTheta_jp1half=dGrid[nTheta][0][j][0];
            if(j==0){
              dTheta_jm1half=dGrid[nTheta][0][j][0]-(dGrid[nTheta][0][j+1][0]-dGrid[nTheta][0][j][0]);
            }
            else{
              dTheta_jm1half=dGrid[nTheta][0][j-1][0];
            }
            dTheta_j=(dTheta_jp1half+dTheta_jm1half)*0.5;
            dA_jp1half=sin(dTheta_jp1half);
            dA_jm1half=sin(dTheta_jm1half);
            dA_j=sin(dTheta_j);
          }
          
          //get P
          dP=dGrid[nD][i][j][nPlaneIndex]*(dGamma-1.0)*dGrid[nE][i][j][nPlaneIndex];
          
          //calculate Q
          dC=sqrt(dGamma*dP/dGrid[nD][i][j][nPlaneIndex]);
          dDVDtThreshold=dAVThreshold*dC;
          
          //Q0
          if(nNumDims>=1){
            if(i==nSizeX1){
              dDVDt=(dA_ip1half*dGrid[nU][i+1][j][nPlaneIndex]
                -dA_im1half*dGrid[nU][i][0][0])/dRSq_i;
            }
            else{
              dDVDt=(dA_ip1half*dGrid[nU][i+1][j][nPlaneIndex]
                -dA_im1half*dGrid[nU][i][j][nPlaneIndex])/dRSq_i;
            }
            if(dDVDt<-1.0*dDVDtThreshold){//being compressed
              dDVDt_mthreshold=dDVDt+dDVDtThreshold;
              dQ0=dASq*dGrid[nD][i][j][nPlaneIndex]*dDVDt_mthreshold*dDVDt_mthreshold;
            }
            else{
              dQ0=0.0;
            }
          }
          
          //Q1
          if(nNumDims>=2){
            if(j==0){
              dDVDt=(dA_jp1half*dGrid[nV][i][j][nPlaneIndex]
                -dA_jm1half*dGrid[nV][i][nSizeY2-1][nPlaneIndex])/dA_j;
            }
            else{
              dDVDt=(dA_jp1half*dGrid[nV][i][j][nPlaneIndex]
                -dA_jm1half*dGrid[nV][i][j-1][nPlaneIndex])/dA_j;
            }
            if(dDVDt<-1.0*dDVDtThreshold){//being compressed
              dDVDt_mthreshold=dDVDt+dDVDtThreshold;
              dQ1=dASq*dGrid[nD][i][j][nPlaneIndex]
                *dDVDt_mthreshold*dDVDt_mthreshold;
            }
            else{
              dQ1=0.0;
            }
          }
          
          //Q2
          if(nNumDims==3){
            if(nPlaneIndex==0){
              dDVDt=(dGrid[nW][i][j][nPlaneIndex]-dGrid[nW][i][j][nSizeZ-1]);
            }
            else{
              dDVDt=(dGrid[nW][i][j][nPlaneIndex]-dGrid[nW][i][j][nPlaneIndex-1]);
            }
            if(dDVDt<-1.0*dDVDtThreshold){//being compressed
              dDVDt_mthreshold=dDVDt+dDVDtThreshold;
              dQ2=dASq*dGrid[nD][i][j][nPlaneIndex]*dDVDt_mthreshold*dDVDt_mthreshold;
            }
            else{
              dQ2=0.0;
            }
          }
          dQ=dQ0+dQ1+dQ2;
          
          dDAve+=dGrid[nD][i][j][nPlaneIndex];
          dEAve+=dGrid[nE][i][j][nPlaneIndex];
          dPAve+=dP;
          dQAve+=dQ;
          nCount++;
        }
        dDAve=dDAve/double(nCount);
        dEAve=dEAve/double(nCount);
        dPAve=dPAve/double(nCount);
        dQAve=dQAve/double(nCount);
      }
      
      for(int j=0;j<nSizeY2;j++){
        dTheta_jp1half=dGrid[nTheta][0][j][0];
        if(j==0){
          dTheta_jm1half=dGrid[nTheta][0][j][0]-(dGrid[nTheta][0][j+1][0]-dGrid[nTheta][0][j][0]);
        }
        else{
          dTheta_jm1half=dGrid[nTheta][0][j-1][0];
        }
        dTheta_j=(dTheta_jp1half+dTheta_jm1half)*0.5;
        dA_jp1half=sin(dTheta_jp1half);
        dA_jm1half=sin(dTheta_jm1half);
        dA_j=sin(dTheta_j);
        
        if(i==nSizeX1){//first zone inside 3D region, has 1D u_im1half
          ofFile<<std::setw(nWidthOutputField)<<dGrid[nU][i][0][0];//0
        }
        else{
          ofFile<<std::setw(nWidthOutputField)<<dGrid[nU][i][j][nPlaneIndex];//0
        }
        ofFile
          <<std::setw(nWidthOutputField)<<dGrid[nU0][i][0][0]//1
          <<std::setw(nWidthOutputField)<<dGrid[nV][i][j][nPlaneIndex];//2
        if (nW!=-1){
          ofFile
            <<std::setw(nWidthOutputField)<<dGrid[nW][i][j][nPlaneIndex];//3
        }
        else{
          ofFile
            <<std::setw(nWidthOutputField)<<"-";//3
        }
        ofFile
          <<std::setw(nWidthOutputField)<<dGrid[nD][i][j][nPlaneIndex]//4
          <<std::setw(nWidthOutputField)<<(dGrid[nD][i][j][nPlaneIndex]-dDAve)/dDAve;//5
        if(nGammaLaw!=0){
          //get P, E, kappa, and gamma
          eosTable.getPEKappaGamma(dGrid[nT][i][j][nPlaneIndex],dGrid[nD][i][j][nPlaneIndex],dP,dE
            ,dKappa,dGamma);
          
          //calculate Q, uses dGamma
          dC=sqrt(dGamma*dP/dGrid[nD][i][j][nPlaneIndex]);
          dDVDtThreshold=dAVThreshold*dC;
          
          //Q0
          if(nNumDims>=1){
            if(i==nSizeX1){
              dDVDt=(dA_ip1half*dGrid[nU][i+1][j][nPlaneIndex]
                -dA_im1half*dGrid[nU][i][0][0])/dRSq_i;
            }
            else{
              dDVDt=(dA_ip1half*dGrid[nU][i+1][j][nPlaneIndex]
                -dA_im1half*dGrid[nU][i][j][nPlaneIndex])/dRSq_i;
            }
            if(dDVDt<-1.0*dDVDtThreshold){//being compressed
              dDVDt_mthreshold=dDVDt+dDVDtThreshold;
              dQ0=dASq*dGrid[nD][i][j][nPlaneIndex]*dDVDt_mthreshold*dDVDt_mthreshold;
            }
            else{
              dQ0=0.0;
            }
          }
          
          //Q1
          if(nNumDims>=2){
            if(j==0){
              dDVDt=(dA_jp1half*dGrid[nV][i][j][nPlaneIndex]
                -dA_jm1half*dGrid[nV][i][nSizeY2-1][nPlaneIndex])/dA_j;
            }
            else{
              dDVDt=(dA_jp1half*dGrid[nV][i][j][nPlaneIndex]
                -dA_jm1half*dGrid[nV][i][j-1][nPlaneIndex])/dA_j;
            }
            if(dDVDt<-1.0*dDVDtThreshold){//being compressed
              dDVDt_mthreshold=dDVDt+dDVDtThreshold;
              dQ1=dASq*dGrid[nD][i][j][nPlaneIndex]
                *dDVDt_mthreshold*dDVDt_mthreshold;
            }
            else{
              dQ1=0.0;
            }
          }
          
          //Q1
          if(nNumDims==3){
            if(nPlaneIndex==0){
              dDVDt=(dGrid[nW][i][j][nPlaneIndex]-dGrid[nW][i][j][nSizeZ-1]);
            }
            else{
              dDVDt=(dGrid[nW][i][j][nPlaneIndex]-dGrid[nW][i][j][nPlaneIndex-1]);
            }
            if(dDVDt<-1.0*dDVDtThreshold){//being compressed
              dDVDt_mthreshold=dDVDt+dDVDtThreshold;
              dQ2=dASq*dGrid[nD][i][j][nPlaneIndex]*dDVDt_mthreshold*dDVDt_mthreshold;
            }
            else{
              dQ2=0.0;
            }
          }
          dQ=dQ0+dQ1+dQ2;
          
          ofFile
            <<std::setw(nWidthOutputField)<<dE<<std::setw(nWidthOutputField)<<(dE-dEAve)/dEAve
            <<std::setw(nWidthOutputField)<<dGrid[nT][i][j][nPlaneIndex]
            <<std::setw(nWidthOutputField)<<(dGrid[nT][i][j][nPlaneIndex]-dTAve)/dTAve
            <<std::setw(nWidthOutputField)<<dP<<std::setw(nWidthOutputField)<<(dP-dPAve)/dPAve;
          if(dQAve==0.0){/*if QAve is zero, this can only be the case if all Q's are zero in the 
            horizontal zone also*/
            ofFile
              <<std::setw(nWidthOutputField)<<dQ<<std::setw(nWidthOutputField)<<0.0;
          }
          else{
            ofFile
              <<std::setw(nWidthOutputField)<<dQ<<std::setw(nWidthOutputField)<<(dQ-dQAve)/dQAve;
          }
          ofFile
            <<std::setw(nWidthOutputField)<<dKappa<<std::setw(nWidthOutputField)
            <<(dKappa-dKappaAve)/dKappaAve
            <<std::setw(nWidthOutputField)<<dGamma<<std::setw(nWidthOutputField)
            <<(dGamma-dGammaAve)/dGammaAve<<std::endl;//8
        }
        else{
          
          //get P
          dP=dGrid[nD][i][j][nPlaneIndex]*(dGamma-1.0)*dGrid[nE][i][j][nPlaneIndex];
          
          //calculate Q
          dC=sqrt(dGamma*dP/dGrid[nD][i][j][nPlaneIndex]);
          dDVDtThreshold=dAVThreshold*dC;
          
          //Q0
          if(nNumDims>=1){
            if(i==nSizeX1){
              dDVDt=(dA_ip1half*dGrid[nU][i+1][j][nPlaneIndex]
                -dA_im1half*dGrid[nU][i][0][0])/dRSq_i;
            }
            else{
              dDVDt=(dA_ip1half*dGrid[nU][i+1][j][nPlaneIndex]
                -dA_im1half*dGrid[nU][i][j][nPlaneIndex])/dRSq_i;
            }
            if(dDVDt<-1.0*dDVDtThreshold){//being compressed
              dDVDt_mthreshold=dDVDt+dDVDtThreshold;
              dQ0=dASq*dGrid[nD][i][j][nPlaneIndex]*dDVDt_mthreshold*dDVDt_mthreshold;
            }
            else{
              dQ0=0.0;
            }
          }
          
          //Q1
          if(nNumDims>=2){
            if(j==0){
              dDVDt=(dA_jp1half*dGrid[nV][i][j][nPlaneIndex]
                -dA_jm1half*dGrid[nV][i][nSizeY2-1][nPlaneIndex])/dA_j;
            }
            else{
              dDVDt=(dA_jp1half*dGrid[nV][i][j][nPlaneIndex]
                -dA_jm1half*dGrid[nV][i][j-1][nPlaneIndex])/dA_j;
            }
            if(dDVDt<-1.0*dDVDtThreshold){//being compressed
              dDVDt_mthreshold=dDVDt+dDVDtThreshold;
              dQ1=dASq*dGrid[nD][i][j][nPlaneIndex]
                *dDVDt_mthreshold*dDVDt_mthreshold;
            }
            else{
              dQ1=0.0;
            }
          }
          
          //Q2
          if(nNumDims==3){
            if(nPlaneIndex==0){
              dDVDt=(dGrid[nW][i][j][nPlaneIndex]-dGrid[nW][i][j][nSizeZ-1]);
            }
            else{
              dDVDt=(dGrid[nW][i][j][nPlaneIndex]-dGrid[nW][i][j][nPlaneIndex-1]);
            }
            if(dDVDt<-1.0*dDVDtThreshold){//being compressed
              dDVDt_mthreshold=dDVDt+dDVDtThreshold;
              dQ2=dASq*dGrid[nD][i][j][nPlaneIndex]*dDVDt_mthreshold*dDVDt_mthreshold;
            }
            else{
              dQ2=0.0;
            }
          }
          dQ=dQ0+dQ1+dQ2;
          
          ofFile
            <<std::setw(nWidthOutputField)<<dE<<std::setw(nWidthOutputField)<<(dE-dEAve)/dEAve
            <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)<<"-"
            <<std::setw(nWidthOutputField)<<dP<<std::setw(nWidthOutputField)<<(dP-dPAve)/dPAve;
          if(dQAve==0.0){/*if QAve is zero, this can only be the case if all Q's are zero in the 
            horizontal zone also*/
            ofFile
              <<std::setw(nWidthOutputField)<<dQ<<std::setw(nWidthOutputField)<<0.0;
          }
          else{
            ofFile
              <<std::setw(nWidthOutputField)<<dQ<<std::setw(nWidthOutputField)<<(dQ-dQAve)/dQAve;
          }
          ofFile
            <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)<<"-"
            <<std::setw(nWidthOutputField)<<dGamma<<std::setw(nWidthOutputField)<<0.0<<std::endl;//8
        }
      }
      ofFile
        <<std::setw(nWidthOutputField)<<"-"
        <<std::setw(nWidthOutputField)<<"-"
        <<std::setw(nWidthOutputField)<<dGrid[nV][i][0][nPlaneIndex]
        <<std::setw(nWidthOutputField)<<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::endl;
    }
    for(int j=0;j<nSizeY2;j++){
      ofFile
        <<std::setw(nWidthOutputField)<<dGrid[nU][nSizeX2][j][nPlaneIndex]
        <<std::setw(nWidthOutputField)<<dGrid[nU0][nSizeX2][0][0]
        <<std::setw(nWidthOutputField)<<"-"
        <<std::setw(nWidthOutputField)<<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::endl;
    }
  }
  if(nPlane==1){//theta-phi
    
    //i
    ofFile<<"im1half[g](0) "<<nPlaneIndex<<" "
      <<nPlaneIndex+1<<std::endl;
    
    //M_r
    ofFile<<"M_r_im1half[g](1) "<<dGrid[nM][nPlaneIndex][0][0]<<" "
      <<dGrid[nM][nPlaneIndex+1][0][0]<<std::endl;
    
    //R
    ofFile<<"R_im1half[cm](2) "<<dGrid[nR][nPlaneIndex][0][0]<<" "
      <<dGrid[nR][nPlaneIndex+1][0][0]<<std::endl;
    
    //j
    ofFile<<"jm1half(3) ";
    for( int j=0;j<nSize[nD][1]+1+2*nNumGhostCells;j++){//add an extra since it is an interface
      ofFile<<j<<" ";
    }
    ofFile<<std::endl;
    
    //write out theta
    int nInterFaceY=0;
    if(nPeriodic[1]==0){
      nInterFaceY=1;
    }
    ofFile<<"theta_jm1half[rad](4) ";
    if(nPeriodic[1]==1){/*write out inner interface if periodic, if not periodic, it is already 
      included*/
      double dInnerTheta=dGrid[nTheta][0][0][0]-(dGrid[nTheta][0][nSize[nD][1]+nNumGhostCells-2][0]
        -dGrid[nTheta][0][nSize[nD][1]+nNumGhostCells-3][0]);
      ofFile<<dInnerTheta<<" ";
     
    }
    for( int j=0;j<nSize[nD][1]+nInterFaceY+2*nNumGhostCells;j++){
      ofFile<<dGrid[nTheta][0][j][0]<<" ";
    }
    ofFile<<std::endl;
    
    //k
    ofFile<<"km1half(5) ";
    for( int k=0;k<nSize[nD][2]+1+2*nNumGhostCells;k++){//add an extra since it is an interface
      ofFile<<k<<" ";
    }
    ofFile<<std::endl;
    
    //write out phi
    int nInterFaceZ=0;
    if(nPeriodic[2]==0){
      nInterFaceZ=1;
    }
    ofFile<<"phi_km1half[rad](6) ";
    if(nPeriodic[2]==1){/*write out inner interface if periodic, if not periodic, it is already
      included*/
      double dInnerTheta=dGrid[nPhi][0][0][0]-(dGrid[nPhi][0][0][nSize[nD][2]+nNumGhostCells-2]
        -dGrid[nPhi][0][0][nSize[nD][2]+nNumGhostCells-3]);
      ofFile<<dInnerTheta<<" ";
     
    }
    for( int k=0;k<nSize[nD][2]+nInterFaceZ+2*nNumGhostCells;k++){
      ofFile<<dGrid[nPhi][0][0][k]<<" ";
    }
    ofFile<<std::endl;
    
    ofFile
      <<std::setw(nWidthOutputField)<<"U_im1halfjk[cm/s](7)"
      <<std::setw(nWidthOutputField)<<"U0_im1half[cm/s](8)"
      <<std::setw(nWidthOutputField)<<"V_ijm1halfk[cm/s](9)"
      <<std::setw(nWidthOutputField)<<"W_ijkm1half[cm/s](10)"
      <<std::setw(nWidthOutputField)<<"D_ijk[g/cm^3](11)"<<std::setw(nWidthOutputField)
      <<"D_rel_dif_hor_ave(12)"
      <<std::setw(nWidthOutputField)<<"E_ijk[erg/g](13)"<<std::setw(nWidthOutputField)
      <<"E_rel_dif_hor_ave(14)"
      <<std::setw(nWidthOutputField)<<"T_ijk[K](15)"<<std::setw(nWidthOutputField)
      <<"T_rel_dif_hor_ave(16)"
      <<std::setw(nWidthOutputField)<<"P_ijk[dynes/cm^2](17)"<<std::setw(nWidthOutputField)
      <<"P_rel_dif_hor_ave(18)"
      <<std::setw(nWidthOutputField)<<"Q_ijk[dynes/cm^2](19)"<<std::setw(nWidthOutputField)
      <<"Q_rel_dif_hor_ave(20)"
      <<std::setw(nWidthOutputField)<<"Kap_ij[cm^2/g](21)"<<std::setw(nWidthOutputField)
      <<"Kap_rel_dif_hor_ave(22)"
      <<std::setw(nWidthOutputField)<<"Gam_ijk[na](23)"<<std::setw(nWidthOutputField)
      <<"Gam_rel_dif_hor_ave(24)"
      <<std::endl;
    
    //3D region
    int nSizeX1=nNum1DZones+nNumGhostCells;
    int nSizeY=nSize[nD][1]+2*nNumGhostCells;
    int nSizeZ=nSize[nD][2]+2*nNumGhostCells;
    int i=nPlaneIndex;
    double dDAve=0.0;
    double dEAve=0.0;
    double dTAve=0.0;
    double dPAve=0.0;
    double dQAve=0.0;
    double dKappaAve=0.0;
    double dGammaAve=0.0;
    int nCount=0;
    dR_i=(dGrid[nR][i+1][0][0]+dGrid[nR][i][0][0])*0.5;
    dRSq_ip1half=dGrid[nR][i+1][0][0]*dGrid[nR][i+1][0][0];
    dRSq_i=dR_i*dR_i;
    dA_ip1half=dGrid[nR][i+1][0][0]*dGrid[nR][i+1][0][0];
    dA_im1half=dGrid[nR][i][0][0]*dGrid[nR][i][0][0];
    
    //calculate horizontal average of various quantities
    if(nGammaLaw!=0){//set P,E,kappa,gamma, Q, and L
      
      for(int j=0;j<nSizeY;j++){
      
        //calculate some theta areas
        dTheta_jp1half=dGrid[nTheta][0][j][0];
        if(j==0){
          dTheta_jm1half=dGrid[nTheta][0][j][0]-(dGrid[nTheta][0][j+1][0]-dGrid[nTheta][0][j][0]);
        }
        else{
          dTheta_jm1half=dGrid[nTheta][0][j-1][0];
        }
        dTheta_j=(dTheta_jp1half+dTheta_jm1half)*0.5;
        dA_jp1half=sin(dTheta_jp1half);
        dA_jm1half=sin(dTheta_jm1half);
        dA_j=sin(dTheta_j);
        
        for(int k=0;k<nSizeZ;k++){
          
          //get P, E, kappa, and gamma
          eosTable.getPEKappaGamma(dGrid[nT][i][j][k],dGrid[nD][i][j][k],dP,dE
            ,dKappa,dGamma);
          
          //calculate Q
          dC=sqrt(dGamma*dP/dGrid[nD][i][j][k]);
          dDVDtThreshold=dAVThreshold*dC;
          
          //Q0
          if(nNumDims>=1){
            if(i==nSizeX1){
              dDVDt=(dA_ip1half*dGrid[nU][i+1][j][k]
                -dA_im1half*dGrid[nU][i][0][0])/dRSq_i;
            }
            else{
              dDVDt=(dA_ip1half*dGrid[nU][i+1][j][k]
                -dA_im1half*dGrid[nU][i][j][k])/dRSq_i;
            }
            if(dDVDt<-1.0*dDVDtThreshold){//being compressed
              dDVDt_mthreshold=dDVDt+dDVDtThreshold;
              dQ0=dASq*dGrid[nD][i][j][k]*dDVDt_mthreshold*dDVDt_mthreshold;
            }
            else{
              dQ0=0.0;
            }
          }
          
          //Q1
          if(nNumDims>=2){
            if(j==0){
              dDVDt=(dA_jp1half*dGrid[nV][i][j][k]
                -dA_jm1half*dGrid[nV][i][nSizeY-1][k])/dA_j;
            }
            else{
              dDVDt=(dA_jp1half*dGrid[nV][i][j][k]
                -dA_jm1half*dGrid[nV][i][j-1][k])/dA_j;
            }
            if(dDVDt<-1.0*dDVDtThreshold){//being compressed
              dDVDt_mthreshold=dDVDt+dDVDtThreshold;
              dQ1=dASq*dGrid[nD][i][j][k]
                *dDVDt_mthreshold*dDVDt_mthreshold;
            }
            else{
              dQ1=0.0;
            }
          }
          
          //Q2
          if(nNumDims==3){
            if(k==0){
              dDVDt=(dGrid[nW][i][j][k]-dGrid[nW][i][j][nSizeZ-1]);
            }
            else{
              dDVDt=(dGrid[nW][i][j][k]-dGrid[nW][i][j][k-1]);
            }
            if(dDVDt<-1.0*dDVDtThreshold){//being compressed
              dDVDt_mthreshold=dDVDt+dDVDtThreshold;
              dQ2=dASq*dGrid[nD][i][j][k]*dDVDt_mthreshold*dDVDt_mthreshold;
            }
            else{
              dQ2=0.0;
            }
          }
          dQ=dQ0+dQ1+dQ2;
          
          dDAve+=dGrid[nD][i][j][k];
          dEAve+=dE;
          dTAve+=dGrid[nT][i][j][k];
          dPAve+=dP;
          dQAve+=dQ;
          dKappaAve+=dKappa;
          dGammaAve+=dGamma;
          nCount++;
        }
      }
      dDAve=dDAve/double(nCount);
      dEAve=dEAve/double(nCount);
      dTAve=dTAve/double(nCount);
      dPAve=dPAve/double(nCount);
      dQAve=dQAve/double(nCount);
      dKappaAve=dKappaAve/double(nCount);
      dGammaAve=dGammaAve/double(nCount);
    }
    else{//set P and Q
      
      for(int j=0;j<nSizeY;j++){
      
        //calculate some theta areas
        dTheta_jp1half=dGrid[nTheta][0][j][0];
        if(j==0){
          dTheta_jm1half=dGrid[nTheta][0][j][0]-(dGrid[nTheta][0][j+1][0]-dGrid[nTheta][0][j][0]);
        }
        else{
          dTheta_jm1half=dGrid[nTheta][0][j-1][0];
        }
        dTheta_j=(dTheta_jp1half+dTheta_jm1half)*0.5;
        dA_jp1half=sin(dTheta_jp1half);
        dA_jm1half=sin(dTheta_jm1half);
        dA_j=sin(dTheta_j);
        
        for(int k=0;k<nSizeZ;k++){
          
          //get P
          dP=dGrid[nD][i][j][k]*(dGamma-1.0)*dGrid[nE][i][j][k];
          
          //calculate Q
          dC=sqrt(dGamma*dP/dGrid[nD][i][j][k]);
          dDVDtThreshold=dAVThreshold*dC;
          
          
          //Q0
          if(nNumDims>=1){
            if(i==nSizeX1){
              dDVDt=(dA_ip1half*dGrid[nU][i+1][j][k]
                -dA_im1half*dGrid[nU][i][0][0])/dRSq_i;
            }
            else{
              dDVDt=(dA_ip1half*dGrid[nU][i+1][j][k]
                -dA_im1half*dGrid[nU][i][j][k])/dRSq_i;
            }
            if(dDVDt<-1.0*dDVDtThreshold){//being compressed
              dDVDt_mthreshold=dDVDt+dDVDtThreshold;
              dQ0=dASq*dGrid[nD][i][j][k]*dDVDt_mthreshold*dDVDt_mthreshold;
            }
            else{
              dQ0=0.0;
            }
          }
          
          //Q1
          if(nNumDims>=2){
            if(j==0){
              dDVDt=(dA_jp1half*dGrid[nV][i][j][k]
                -dA_jm1half*dGrid[nV][i][nSizeY-1][k])/dA_j;
            }
            else{
              dDVDt=(dA_jp1half*dGrid[nV][i][j][k]
                -dA_jm1half*dGrid[nV][i][j-1][k])/dA_j;
            }
            if(dDVDt<-1.0*dDVDtThreshold){//being compressed
              dDVDt_mthreshold=dDVDt+dDVDtThreshold;
              dQ1=dASq*dGrid[nD][i][j][k]
                *dDVDt_mthreshold*dDVDt_mthreshold;
            }
            else{
              dQ1=0.0;
            }
          }
          
          //Q2
          if(nNumDims==3){
            if(k==0){
              dDVDt=(dGrid[nW][i][j][k]-dGrid[nW][i][j][nSizeZ-1]);
            }
            else{
              dDVDt=(dGrid[nW][i][j][k]-dGrid[nW][i][j][k-1]);
            }
            if(dDVDt<-1.0*dDVDtThreshold){//being compressed
              dDVDt_mthreshold=dDVDt+dDVDtThreshold;
              dQ2=dASq*dGrid[nD][i][j][k]*dDVDt_mthreshold*dDVDt_mthreshold;
            }
            else{
              dQ2=0.0;
            }
          }
          dQ=dQ0+dQ1+dQ2;
          
          dDAve+=dGrid[nD][i][j][k];
          dEAve+=dGrid[nE][i][j][k];
          dPAve+=dP;
          dQAve+=dQ;
          nCount++;
        }
      }
      dDAve=dDAve/double(nCount);
      dEAve=dEAve/double(nCount);
      dPAve=dPAve/double(nCount);
      dQAve=dQAve/double(nCount);
    }
    
    for(int j=0;j<nSizeY;j++){
      
      //calculate some theta areas
      dTheta_jp1half=dGrid[nTheta][0][j][0];
      if(j==0){
        dTheta_jm1half=dGrid[nTheta][0][j][0]-(dGrid[nTheta][0][j+1][0]-dGrid[nTheta][0][j][0]);
      }
      else{
        dTheta_jm1half=dGrid[nTheta][0][j-1][0];
      }
      dTheta_j=(dTheta_jp1half+dTheta_jm1half)*0.5;
      dA_jp1half=sin(dTheta_jp1half);
      dA_jm1half=sin(dTheta_jm1half);
      dA_j=sin(dTheta_j);
      
      for(int k=0;k<nSizeZ;k++){
        
        ofFile
          <<std::setw(nWidthOutputField)<<dGrid[nU][i][j][k]//0
          <<std::setw(nWidthOutputField)<<dGrid[nU0][i][0][0]//1
          <<std::setw(nWidthOutputField)<<dGrid[nV][i][j][k];//2
        if(nW!=-1){
          ofFile
            <<std::setw(nWidthOutputField)<<dGrid[nW][i][j][k];//3
        }
        else{
          ofFile
            <<std::setw(nWidthOutputField)<<"-";//3
        }
        ofFile
          <<std::setw(nWidthOutputField)<<dGrid[nD][i][j][k]//4
          <<std::setw(nWidthOutputField)<<(dGrid[nD][i][j][k]-dDAve)/dDAve;//5
        if(nGammaLaw!=0){
          //get P, E, kappa, and gamma
          eosTable.getPEKappaGamma(dGrid[nT][i][j][k],dGrid[nD][i][j][k],dP,dE
            ,dKappa,dGamma);
          
          //calculate Q
          dC=sqrt(dGamma*dP/dGrid[nD][i][j][k]);
          dDVDtThreshold=dAVThreshold*dC;
          if(nNumDims>=1){
            if(i==nSizeX1){
              dDVDt=(dA_ip1half*dGrid[nU][i+1][j][k]
                -dA_im1half*dGrid[nU][i][0][0])/dRSq_i;
            }
            else{
              dDVDt=(dA_ip1half*dGrid[nU][i+1][j][k]
                -dA_im1half*dGrid[nU][i][j][k])/dRSq_i;
            }
            if(dDVDt<-1.0*dDVDtThreshold){//being compressed
              dDVDt_mthreshold=dDVDt+dDVDtThreshold;
              dQ0=dASq*dGrid[nD][i][j][k]*dDVDt_mthreshold*dDVDt_mthreshold;
            }
            else{
              dQ0=0.0;
            }
          }
          else if(nNumDims>=2){
            if(j==0){
              dDVDt=(dA_jp1half*dGrid[nV][i][j][k]
                -dA_jm1half*dGrid[nV][i][nSizeY-1][k])/dA_j;
            }
            else{
              dDVDt=(dA_jp1half*dGrid[nV][i][j][k]
                -dA_jm1half*dGrid[nV][i][j-1][k])/dA_j;
            }
            if(dDVDt<-1.0*dDVDtThreshold){//being compressed
              dDVDt_mthreshold=dDVDt+dDVDtThreshold;
              dQ1=dASq*dGrid[nD][i][j][k]
                *dDVDt_mthreshold*dDVDt_mthreshold;
            }
            else{
              dQ1=0.0;
            }
          }
          else if(nNumDims==3){
            if(k==0){
              dDVDt=(dGrid[nW][i][j][k]-dGrid[nW][i][j][nSizeZ-1]);
            }
            else{
              dDVDt=(dGrid[nW][i][j][k]-dGrid[nW][i][j][k-1]);
            }
            if(dDVDt<-1.0*dDVDtThreshold){//being compressed
              dDVDt_mthreshold=dDVDt+dDVDtThreshold;
              dQ2=dASq*dGrid[nD][i][j][k]*dDVDt_mthreshold*dDVDt_mthreshold;
            }
            else{
              dQ2=0.0;
            }
          }
          dQ=dQ0+dQ1+dQ2;
          
          ofFile
            <<std::setw(nWidthOutputField)<<dE<<std::setw(nWidthOutputField)<<(dE-dEAve)/dEAve
            <<std::setw(nWidthOutputField)<<dGrid[nT][i][j][k]
            <<std::setw(nWidthOutputField)<<(dGrid[nT][i][j][k]-dTAve)/dTAve
            <<std::setw(nWidthOutputField)<<dP<<std::setw(nWidthOutputField)<<(dP-dPAve)/dPAve;
          if(dQAve==0.0){/*if QAve is zero, this can only be the case if all Q's are zero in the 
            horizontal zone also*/
            ofFile
              <<std::setw(nWidthOutputField)<<dQ<<std::setw(nWidthOutputField)<<0.0;
          }
          else{
            ofFile
              <<std::setw(nWidthOutputField)<<dQ<<std::setw(nWidthOutputField)<<(dQ-dQAve)/dQAve;
          }
          ofFile
            <<std::setw(nWidthOutputField)<<dKappa<<std::setw(nWidthOutputField)
            <<(dKappa-dKappaAve)/dKappaAve
            <<std::setw(nWidthOutputField)<<dGamma<<std::setw(nWidthOutputField)
            <<(dGamma-dGammaAve)/dGammaAve<<std::endl;//8
        }
        else{
          
          //get P
          dP=dGrid[nD][i][j][k]*(dGamma-1.0)*dGrid[nE][i][j][k];
          
          //calculate Q
          dC=sqrt(dGamma*dP/dGrid[nD][i][j][k]);
          dDVDtThreshold=dAVThreshold*dC;
          
          //Q0
          if(nNumDims>=1){
            if(i==nSizeX1){
              dDVDt=(dA_ip1half*dGrid[nU][i+1][j][k]
                -dA_im1half*dGrid[nU][i][0][0])/dRSq_i;
            }
            else{
              dDVDt=(dA_ip1half*dGrid[nU][i+1][j][k]
                -dA_im1half*dGrid[nU][i][j][k])/dRSq_i;
            }
            if(dDVDt<-1.0*dDVDtThreshold){//being compressed
              dDVDt_mthreshold=dDVDt+dDVDtThreshold;
              dQ0=dASq*dGrid[nD][i][j][k]*dDVDt_mthreshold*dDVDt_mthreshold;
            }
            else{
              dQ0=0.0;
            }
          }
          
          //Q1
          if(nNumDims>=2){
            if(j==0){
              dDVDt=(dA_jp1half*dGrid[nV][i][j][k]
                -dA_jm1half*dGrid[nV][i][nSizeY-1][k])/dA_j;
            }
            else{
              dDVDt=(dA_jp1half*dGrid[nV][i][j][k]
                -dA_jm1half*dGrid[nV][i][j-1][k])/dA_j;
            }
            if(dDVDt<-1.0*dDVDtThreshold){//being compressed
              dDVDt_mthreshold=dDVDt+dDVDtThreshold;
              dQ1=dASq*dGrid[nD][i][j][k]
                *dDVDt_mthreshold*dDVDt_mthreshold;
            }
            else{
              dQ1=0.0;
            }
          }
          
          //Q2
          if(nNumDims==3){
            if(k==0){
              dDVDt=(dGrid[nW][i][j][k]-dGrid[nW][i][j][nSizeZ-1]);
            }
            else{
              dDVDt=(dGrid[nW][i][j][k]-dGrid[nW][i][j][k-1]);
            }
            if(dDVDt<-1.0*dDVDtThreshold){//being compressed
              dDVDt_mthreshold=dDVDt+dDVDtThreshold;
              dQ2=dASq*dGrid[nD][i][j][k]*dDVDt_mthreshold*dDVDt_mthreshold;
            }
            else{
              dQ2=0.0;
            }
          }
          dQ=dQ0+dQ1+dQ2;
          
          ofFile
            <<std::setw(nWidthOutputField)<<dE<<std::setw(nWidthOutputField)<<(dE-dEAve)/dEAve
            <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)<<"-"
            <<std::setw(nWidthOutputField)<<dP<<std::setw(nWidthOutputField)<<(dP-dPAve)/dPAve;
          if(dQAve==0.0){/*if QAve is zero, this can only be the case if all Q's are zero in the 
            horizontal zone also*/
            ofFile
              <<std::setw(nWidthOutputField)<<dQ<<std::setw(nWidthOutputField)<<0.0;
          }
          else{
            ofFile
              <<std::setw(nWidthOutputField)<<dQ<<std::setw(nWidthOutputField)<<(dQ-dQAve)/dQAve;
          }
          ofFile
            <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)<<"-"
            <<std::setw(nWidthOutputField)<<dGamma<<std::setw(nWidthOutputField)<<0.0<<std::endl;//8
        }
      }
      ofFile
        <<std::setw(nWidthOutputField)<<"-"
        <<std::setw(nWidthOutputField)<<"-"
        <<std::setw(nWidthOutputField)<<"-";
      if(nW!=-1){
        ofFile
          <<std::setw(nWidthOutputField)<<dGrid[nW][i][j][0];
      }
      else{
        ofFile
          <<std::setw(nWidthOutputField)<<"-";
      }
      ofFile
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::endl;
    }
    for(int k=0;k<nSizeZ;k++){
      ofFile
        <<std::setw(nWidthOutputField)<<"-"
        <<std::setw(nWidthOutputField)<<"-"
        <<std::setw(nWidthOutputField)<<dGrid[nV][i][0][k]
        <<std::setw(nWidthOutputField)<<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::endl;
    }
  }
  if(nPlane==2){//r-phi
     
    //i
    ofFile<<"im1half(0) ";
    for( int i=0;i<nSize[nR][0]+2*nNumGhostCells;i++){
      ofFile<<i<<" ";
    }
    ofFile<<std::endl;
    
    //M_r
    ofFile<<"M_r_im1half[g](1) ";
    for( int i=0;i<nSize[nR][0]+2*nNumGhostCells;i++){
      ofFile<<dGrid[nM][i][0][0]<<" ";
    }
    ofFile<<std::endl;
    
    //R
    ofFile<<"R_im1half[cm](2) ";
    for( int i=0;i<nSize[nR][0]+2*nNumGhostCells;i++){
      ofFile<<dGrid[nR][i][0][0]<<" ";
    }
    ofFile<<std::endl;
    
    //j
    if(nNumDims>2){
      ofFile<<"jm1half(3) "<<nPlaneIndex<<" "<<nPlaneIndex+1<<std::endl;
    }
    else{
      ofFile<<"jm1half(3) "<<0<<" "<<1<<std::endl;
    }
    
    //theta
    ofFile<<"theta_jm1half[rad](4) "<<dGrid[nTheta][0][nPlaneIndex][0]<<" ";
    if(nPlaneIndex==nSize[nTheta][1]+2*nNumGhostCells-1){//if in last zone, need to do something to get outter phi
      ofFile<<dGrid[nTheta][0][nPlaneIndex][0]+(dGrid[nTheta][0][nPlaneIndex][0]
        -dGrid[nTheta][0][nPlaneIndex-1][0])<<std::endl;
    }
    else{
      ofFile<<dGrid[nTheta][0][nPlaneIndex+1][0]<<std::endl;
    }
    
    //k
    ofFile<<"km1half(5) ";
    for( int k=0;k<nSize[nD][2]+1+2*nNumGhostCells;k++){//add an extra since it is an interface
      ofFile<<k<<" ";
    }
    ofFile<<std::endl;
    
    //phi
    int nInterFaceZ=0;
    if(nPeriodic[2]==0){
      nInterFaceZ=1;
    }
    ofFile<<"phi_km1half[rad](6) ";
    if(nPeriodic[2]==1){/*write out inner interface if periodic, if not periodic, it is already
      included*/
      double dInnerTheta=dGrid[nPhi][0][0][0]-(dGrid[nPhi][0][0][nSize[nD][2]+nNumGhostCells-2]
        -dGrid[nPhi][0][0][nSize[nD][2]+nNumGhostCells-3]);
      ofFile<<dInnerTheta<<" ";
     
    }
    for( int k=0;k<nSize[nD][2]+nInterFaceZ+2*nNumGhostCells;k++){
      ofFile<<dGrid[nPhi][0][0][k]<<" ";
    }
    ofFile<<std::endl;
    
    ofFile
      <<std::setw(nWidthOutputField)<<"U_im1halfjk[cm/s](7)"
      <<std::setw(nWidthOutputField)<<"U0_im1half[cm/s](8)"
      <<std::setw(nWidthOutputField)<<"V_ijm1halfk[cm/s](9)"
      <<std::setw(nWidthOutputField)<<"W_ijkm1half[cm/s](10)"
      <<std::setw(nWidthOutputField)<<"D_ijk[g/cm^3](11)"<<std::setw(nWidthOutputField)
      <<"D_rel_dif_hor_ave(12)"
      <<std::setw(nWidthOutputField)<<"E_ijk[erg/g](13)"<<std::setw(nWidthOutputField)
      <<"E_rel_dif_hor_ave(14)"
      <<std::setw(nWidthOutputField)<<"T_ijk[K](15)"<<std::setw(nWidthOutputField)
      <<"T_rel_dif_hor_ave(16)"
      <<std::setw(nWidthOutputField)<<"P_ijk[dynes/cm^2](17)"<<std::setw(nWidthOutputField)
      <<"P_rel_dif_hor_ave(18)"
      <<std::setw(nWidthOutputField)<<"Q_ijk[dynes/cm^2](19)"<<std::setw(nWidthOutputField)
      <<"Q_rel_dif_hor_ave(20)"
      <<std::setw(nWidthOutputField)<<"Kap_ij[cm^2/g](21)"<<std::setw(nWidthOutputField)
      <<"Kap_rel_dif_hor_ave(22)"
      <<std::setw(nWidthOutputField)<<"Gam_ijk[na](23)"<<std::setw(nWidthOutputField)
      <<"Gam_rel_dif_hor_ave(24)"
      <<std::endl;
    
    //1D region
    int nSizeX1=nNum1DZones+nNumGhostCells;
    int nSizeY2=nSize[nD][1]+2*nNumGhostCells;
    int nSizeZ=nSize[nD][2]+2*nNumGhostCells;
    for(int i=0;i<nSizeX1;i++){
      dR_i=(dGrid[nR][i+1][0][0]+dGrid[nR][i][0][0])*0.5;
      dRSq_ip1half=dGrid[nR][i+1][0][0]*dGrid[nR][i+1][0][0];
      dRSq_i=dR_i*dR_i;
      dA_ip1half=dGrid[nR][i+1][0][0]*dGrid[nR][i+1][0][0];
      dA_im1half=dGrid[nR][i][0][0]*dGrid[nR][i][0][0];
      for(int k=0;k<nSizeZ;k++){
        
        ofFile
          <<std::setw(nWidthOutputField)<<dGrid[nU][i][0][0]//0
          <<std::setw(nWidthOutputField)<<dGrid[nU0][i][0][0]//1
          <<std::setw(nWidthOutputField)<<0.0//2
          <<std::setw(nWidthOutputField)<<0.0//3
          <<std::setw(nWidthOutputField)<<dGrid[nD][i][0][0]<<std::setw(nWidthOutputField)<<0.0;//4,5
        
        if(nGammaLaw!=0){//set P,E,kappa,gamma, Q, and L
          
          //get P, E, kappa, and gamma
          eosTable.getPEKappaGamma(dGrid[nT][i][0][0],dGrid[nD][i][0][0],dP,dE,dKappa,dGamma);
          
          //calculate Q
          dC=sqrt(dGamma*dP/dGrid[nD][i][0][0]);
          dDVDtThreshold=dAVThreshold*dC;
          dDVDt=(dA_ip1half*dGrid[nU][i+1][0][0]
            -dA_im1half*dGrid[nU][i][0][0])/dRSq_i;
          if(dDVDt<-1.0*dDVDtThreshold){//being compressed
            dDVDt_mthreshold=dDVDt+dDVDtThreshold;
            dQ=dASq*dGrid[nD][i][0][0]*dDVDt_mthreshold*dDVDt_mthreshold;
          }
          else{
            dQ=0.0;
          }
          
          //print them out
          ofFile
            <<std::setw(nWidthOutputField)<<dE<<std::setw(nWidthOutputField)<<0.0//6,7
            <<std::setw(nWidthOutputField)<<dGrid[nT][i][0][0]<<std::setw(nWidthOutputField)<<0.0//8,9
            <<std::setw(nWidthOutputField)<<dP<<std::setw(nWidthOutputField)<<0.0//10,11
            <<std::setw(nWidthOutputField)<<dQ<<std::setw(nWidthOutputField)<<0.0//12,13
            <<std::setw(nWidthOutputField)<<dKappa<<std::setw(nWidthOutputField)<<0.0//14,15
            <<std::setw(nWidthOutputField)<<dGamma<<std::setw(nWidthOutputField)<<0.0;//16,17
          
        }
        else{//set P and Q
          
          dP=dGrid[nD][i][0][0]*(dGamma-1.0)*dGrid[nE][i][0][0];
          
          
          //calculate Q
          dR_i=(dGrid[nR][i+1][0][0]+dGrid[nR][i][0][0])*0.5;
          dRSq_i=dR_i*dR_i;
          dA_ip1half=dGrid[nR][i+1][0][0]*dGrid[nR][i+1][0][0];
          dA_im1half=dGrid[nR][i][0][0]*dGrid[nR][i][0][0];
          dC=sqrt(dGamma*dP/dGrid[nD][i][0][0]);
          dDVDtThreshold=dAVThreshold*dC;
          dDVDt=(dA_ip1half*dGrid[nU][i+1][0][0]
            -dA_im1half*dGrid[nU][i][0][0])/dRSq_i;
          if(dDVDt<-1.0*dDVDtThreshold){//being compressed
            dDVDt_mthreshold=dDVDt+dDVDtThreshold;
            dQ=dASq*dGrid[nD][i][0][0]*dDVDt_mthreshold*dDVDt_mthreshold;
          }
          else{
            dQ=0.0;
          }
          
          //print them out
          ofFile
            <<std::setw(nWidthOutputField)<<dGrid[nE][i][0][0]<<std::setw(nWidthOutputField)<<0.0//6,7
            <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)<<"-"//8,9
            <<std::setw(nWidthOutputField)<<dP<<std::setw(nWidthOutputField)<<0.0//10,11
            <<std::setw(nWidthOutputField)<<dQ<<std::setw(nWidthOutputField)<<0.0//12,13
            <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)<<"-"//14,15
            <<std::setw(nWidthOutputField)<<dGamma<<std::setw(nWidthOutputField)<<0.0;//16,17
        }
        ofFile<<std::endl;
      }
      ofFile
        <<std::setw(nWidthOutputField)<<"-"
        <<std::setw(nWidthOutputField)<<"-"
        <<std::setw(nWidthOutputField)<<"-";
      if(nW!=-1){
        ofFile
          <<std::setw(nWidthOutputField)<<0.0;
      }
      else{
        ofFile
          <<std::setw(nWidthOutputField)<<"-";
      }
      ofFile
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::endl;
    }
    
    //3D region
    int nSizeX2=nSize[nD][0]+2*nNumGhostCells;
    for(int i=nSizeX1;i<nSizeX2;i++){
      
      dR_i=(dGrid[nR][i+1][0][0]+dGrid[nR][i][0][0])*0.5;
      dRSq_ip1half=dGrid[nR][i+1][0][0]*dGrid[nR][i+1][0][0];
      dRSq_i=dR_i*dR_i;
      dA_ip1half=dGrid[nR][i+1][0][0]*dGrid[nR][i+1][0][0];
      dA_im1half=dGrid[nR][i][0][0]*dGrid[nR][i][0][0];
      
      //calculate horizontal average of various quantities
      double dDAve=0.0;
      double dEAve=0.0;
      double dTAve=0.0;
      double dPAve=0.0;
      double dQAve=0.0;
      double dKappaAve=0.0;
      double dGammaAve=0.0;
      int nCount=0;
      
      //calculate some theta areas
      if(nNumDims>1){
        dTheta_jp1half=dGrid[nTheta][0][nPlaneIndex][0];
        if(nPlaneIndex==0){
          dTheta_jm1half=dGrid[nTheta][0][nPlaneIndex][0]-(dGrid[nTheta][0][nPlaneIndex+1][0]
            -dGrid[nTheta][0][nPlaneIndex][0]);
        }
        else{
          dTheta_jm1half=dGrid[nTheta][0][nPlaneIndex-1][0];
        }
        dTheta_j=(dTheta_jp1half+dTheta_jm1half)*0.5;
        dA_jp1half=sin(dTheta_jp1half);
        dA_jm1half=sin(dTheta_jm1half);
        dA_j=sin(dTheta_j);
      }
      
      if(nGammaLaw!=0){//set P,E,kappa,gamma, Q, and L
        
        for(int k=0;k<nSizeZ;k++){
          
          //get P, E, kappa, and gamma
          eosTable.getPEKappaGamma(dGrid[nT][i][nPlaneIndex][k],dGrid[nD][i][nPlaneIndex][k],dP,dE
            ,dKappa,dGamma);
          
          //calculate Q
          dC=sqrt(dGamma*dP/dGrid[nD][i][nPlaneIndex][k]);
          dDVDtThreshold=dAVThreshold*dC;
          
          //Q0
          if(nNumDims>=1){
            if(i==nSizeX1){
              dDVDt=(dA_ip1half*dGrid[nU][i+1][nPlaneIndex][k]
                -dA_im1half*dGrid[nU][i][0][0])/dRSq_i;
            }
            else{
              dDVDt=(dA_ip1half*dGrid[nU][i+1][nPlaneIndex][k]
                -dA_im1half*dGrid[nU][i][nPlaneIndex][k])/dRSq_i;
            }
            if(dDVDt<-1.0*dDVDtThreshold){//being compressed
              dDVDt_mthreshold=dDVDt+dDVDtThreshold;
              dQ0=dASq*dGrid[nD][i][nPlaneIndex][k]*dDVDt_mthreshold*dDVDt_mthreshold;
            }
            else{
              dQ0=0.0;
            }
          }
          
          //Q1
          if(nNumDims>=2){
            if(nPlaneIndex==0){
              dDVDt=(dA_jp1half*dGrid[nV][i][nPlaneIndex][k]
                -dA_jm1half*dGrid[nV][i][nSizeY2-1][k])/dA_j;
            }
            else{
              dDVDt=(dA_jp1half*dGrid[nV][i][nPlaneIndex][k]
                -dA_jm1half*dGrid[nV][i][nPlaneIndex-1][k])/dA_j;
            }
            if(dDVDt<-1.0*dDVDtThreshold){//being compressed
              dDVDt_mthreshold=dDVDt+dDVDtThreshold;
              dQ1=dASq*dGrid[nD][i][nPlaneIndex][k]
                *dDVDt_mthreshold*dDVDt_mthreshold;
            }
            else{
              dQ1=0.0;
            }
          }
          
          //Q2
          if(nNumDims==3){
            if(k==0){
              dDVDt=(dGrid[nW][i][nPlaneIndex][k]-dGrid[nW][i][nPlaneIndex][nSizeZ-1]);
            }
            else{
              dDVDt=(dGrid[nW][i][nPlaneIndex][k]-dGrid[nW][i][nPlaneIndex][k-1]);
            }
            if(dDVDt<-1.0*dDVDtThreshold){//being compressed
              dDVDt_mthreshold=dDVDt+dDVDtThreshold;
              dQ2=dASq*dGrid[nD][i][nPlaneIndex][k]*dDVDt_mthreshold*dDVDt_mthreshold;
            }
            else{
              dQ2=0.0;
            }
          }
          dQ=dQ0+dQ1+dQ2;
          
          dDAve+=dGrid[nD][i][nPlaneIndex][k];
          dEAve+=dE;
          dTAve+=dGrid[nT][i][nPlaneIndex][k];
          dPAve+=dP;
          dQAve+=dQ;
          dKappaAve+=dKappa;
          dGammaAve+=dGamma;
          nCount++;
        }
        dDAve=dDAve/double(nCount);
        dEAve=dEAve/double(nCount);
        dTAve=dTAve/double(nCount);
        dPAve=dPAve/double(nCount);
        dQAve=dQAve/double(nCount);
        dKappaAve=dKappaAve/double(nCount);
        dGammaAve=dGammaAve/double(nCount);
      }
      else{//set P and Q
        
        for(int k=0;k<nSizeZ;k++){
          
          if(nNumDims>1){
            dTheta_jp1half=dGrid[nTheta][0][nPlaneIndex][0];
            if(nPlaneIndex==0){
              dTheta_jm1half=dGrid[nTheta][0][nPlaneIndex][0]-(dGrid[nTheta][0][nPlaneIndex+1][0]
                -dGrid[nTheta][0][nPlaneIndex][0]);
            }
            else{
              dTheta_jm1half=dGrid[nTheta][0][nPlaneIndex-1][0];
            }
            dTheta_j=(dTheta_jp1half+dTheta_jm1half)*0.5;
            dA_jp1half=sin(dTheta_jp1half);
            dA_jm1half=sin(dTheta_jm1half);
            dA_j=sin(dTheta_j);
          }
          
          //get P
          dP=dGrid[nD][i][nPlaneIndex][k]*(dGamma-1.0)*dGrid[nE][i][nPlaneIndex][k];
          
          //calculate Q
          dC=sqrt(dGamma*dP/dGrid[nD][i][nPlaneIndex][k]);
          dDVDtThreshold=dAVThreshold*dC;
          
          //Q0
          if(nNumDims>=1){
            if(i==nSizeX1){
              dDVDt=(dA_ip1half*dGrid[nU][i+1][nPlaneIndex][k]
                -dA_im1half*dGrid[nU][i][0][0])/dRSq_i;
            }
            else{
              dDVDt=(dA_ip1half*dGrid[nU][i+1][nPlaneIndex][k]
                -dA_im1half*dGrid[nU][i][nPlaneIndex][k])/dRSq_i;
            }
            if(dDVDt<-1.0*dDVDtThreshold){//being compressed
              dDVDt_mthreshold=dDVDt+dDVDtThreshold;
              dQ0=dASq*dGrid[nD][i][nPlaneIndex][k]*dDVDt_mthreshold*dDVDt_mthreshold;
            }
            else{
              dQ0=0.0;
            }
          }
          
          //Q1
          if(nNumDims>=2){
            if(nPlaneIndex==0){
              dDVDt=(dA_jp1half*dGrid[nV][i][nPlaneIndex][k]
                -dA_jm1half*dGrid[nV][i][nSizeY2-1][k])/dA_j;
            }
            else{
              dDVDt=(dA_jp1half*dGrid[nV][i][nPlaneIndex][k]
                -dA_jm1half*dGrid[nV][i][nPlaneIndex-1][k])/dA_j;
            }
            if(dDVDt<-1.0*dDVDtThreshold){//being compressed
              dDVDt_mthreshold=dDVDt+dDVDtThreshold;
              dQ1=dASq*dGrid[nD][i][nPlaneIndex][k]
                *dDVDt_mthreshold*dDVDt_mthreshold;
            }
            else{
              dQ1=0.0;
            }
          }
          
          //Q2
          if(nNumDims==3){
            if(k==0){
              dDVDt=(dGrid[nW][i][nPlaneIndex][k]-dGrid[nW][i][nPlaneIndex][nSizeZ-1]);
            }
            else{
              dDVDt=(dGrid[nW][i][nPlaneIndex][k]-dGrid[nW][i][nPlaneIndex][k-1]);
            }
            if(dDVDt<-1.0*dDVDtThreshold){//being compressed
              dDVDt_mthreshold=dDVDt+dDVDtThreshold;
              dQ2=dASq*dGrid[nD][i][nPlaneIndex][k]*dDVDt_mthreshold*dDVDt_mthreshold;
            }
            else{
              dQ2=0.0;
            }
          }
          dQ=dQ0+dQ1+dQ2;
          
          dDAve+=dGrid[nD][i][nPlaneIndex][k];
          dEAve+=dGrid[nE][i][nPlaneIndex][k];
          dPAve+=dP;
          dQAve+=dQ;
          nCount++;
        }
        dDAve=dDAve/double(nCount);
        dEAve=dEAve/double(nCount);
        dPAve=dPAve/double(nCount);
        dQAve=dQAve/double(nCount);
      }
      
      for(int k=0;k<nSizeZ;k++){

        if(nNumDims>1){
          dTheta_jp1half=dGrid[nTheta][0][nPlaneIndex][0];
          if(nPlaneIndex==0){
            dTheta_jm1half=dGrid[nTheta][0][nPlaneIndex][0]-(dGrid[nTheta][0][nPlaneIndex+1][0]
              -dGrid[nTheta][0][nPlaneIndex][0]);
          }
          else{
            dTheta_jm1half=dGrid[nTheta][0][nPlaneIndex-1][0];
          }
          dTheta_j=(dTheta_jp1half+dTheta_jm1half)*0.5;
          dA_jp1half=sin(dTheta_jp1half);
          dA_jm1half=sin(dTheta_jm1half);
          dA_j=sin(dTheta_j);
        }
        
        if(i==nSizeX1){//first zone inside 3D region, has 1D u_im1half
          ofFile<<std::setw(nWidthOutputField)<<dGrid[nU][i][0][0];//0
        }
        else{
          ofFile<<std::setw(nWidthOutputField)<<dGrid[nU][i][nPlaneIndex][k];//0
        }
        ofFile
          <<std::setw(nWidthOutputField)<<dGrid[nU0][i][0][0]//1
          <<std::setw(nWidthOutputField)<<dGrid[nV][i][nPlaneIndex][k];//2
        if(nW!=-1){
          ofFile
            <<std::setw(nWidthOutputField)<<dGrid[nW][i][nPlaneIndex][k];//2
        }
        else{
          ofFile
            <<std::setw(nWidthOutputField)<<"-";//2
        }
        ofFile
          <<std::setw(nWidthOutputField)<<dGrid[nD][i][nPlaneIndex][k]//3
          <<std::setw(nWidthOutputField)<<(dGrid[nD][i][nPlaneIndex][k]-dDAve)/dDAve;//4
        if(nGammaLaw!=0){
          //get P, E, kappa, and gamma
          eosTable.getPEKappaGamma(dGrid[nT][i][nPlaneIndex][k],dGrid[nD][i][nPlaneIndex][k],dP,dE
            ,dKappa,dGamma);
          
          //calculate Q
          dC=sqrt(dGamma*dP/dGrid[nD][i][nPlaneIndex][k]);
          dDVDtThreshold=dAVThreshold*dC;
          
          //Q0
          if(nNumDims>=1){
            if(i==nSizeX1){
              dDVDt=(dA_ip1half*dGrid[nU][i+1][nPlaneIndex][k]
                -dA_im1half*dGrid[nU][i][0][0])/dRSq_i;
            }
            else{
              dDVDt=(dA_ip1half*dGrid[nU][i+1][nPlaneIndex][k]
                -dA_im1half*dGrid[nU][i][nPlaneIndex][k])/dRSq_i;
            }
            if(dDVDt<-1.0*dDVDtThreshold){//being compressed
              dDVDt_mthreshold=dDVDt+dDVDtThreshold;
              dQ0=dASq*dGrid[nD][i][nPlaneIndex][k]*dDVDt_mthreshold*dDVDt_mthreshold;
            }
            else{
              dQ0=0.0;
            }
          }
          
          //Q1
          if(nNumDims>=2){
            if(nPlaneIndex==0){
              dDVDt=(dA_jp1half*dGrid[nV][i][nPlaneIndex][k]
                -dA_jm1half*dGrid[nV][i][nSizeY2-1][k])/dA_j;
            }
            else{
              dDVDt=(dA_jp1half*dGrid[nV][i][nPlaneIndex][k]
                -dA_jm1half*dGrid[nV][i][nPlaneIndex-1][k])/dA_j;
            }
            if(dDVDt<-1.0*dDVDtThreshold){//being compressed
              dDVDt_mthreshold=dDVDt+dDVDtThreshold;
              dQ1=dASq*dGrid[nD][i][nPlaneIndex][k]
                *dDVDt_mthreshold*dDVDt_mthreshold;
            }
            else{
              dQ1=0.0;
            }
          }
          
          //Q2
          if(nNumDims==3){
            if(k==0){
              dDVDt=(dGrid[nW][i][nPlaneIndex][k]-dGrid[nW][i][nPlaneIndex][nSizeZ-1]);
            }
            else{
              dDVDt=(dGrid[nW][i][nPlaneIndex][k]-dGrid[nW][i][nPlaneIndex][k-1]);
            }
            if(dDVDt<-1.0*dDVDtThreshold){//being compressed
              dDVDt_mthreshold=dDVDt+dDVDtThreshold;
              dQ2=dASq*dGrid[nD][i][nPlaneIndex][k]*dDVDt_mthreshold*dDVDt_mthreshold;
            }
            else{
              dQ2=0.0;
            }
          }
          dQ=dQ0+dQ1+dQ2;
          
          ofFile
            <<std::setw(nWidthOutputField)<<dE<<std::setw(nWidthOutputField)<<(dE-dEAve)/dEAve
            <<std::setw(nWidthOutputField)<<dGrid[nT][i][nPlaneIndex][k]
            <<std::setw(nWidthOutputField)<<(dGrid[nT][i][nPlaneIndex][k]-dTAve)/dTAve
            <<std::setw(nWidthOutputField)<<dP<<std::setw(nWidthOutputField)<<(dP-dPAve)/dPAve;
          if(dQAve==0.0){/*if QAve is zero, this can only be the case if all Q's are zero in the 
            horizontal zone also*/
            ofFile
              <<std::setw(nWidthOutputField)<<dQ<<std::setw(nWidthOutputField)<<0.0;
          }
          else{
            ofFile
              <<std::setw(nWidthOutputField)<<dQ<<std::setw(nWidthOutputField)<<(dQ-dQAve)/dQAve;
          }
          ofFile
            <<std::setw(nWidthOutputField)<<dKappa<<std::setw(nWidthOutputField)
            <<(dKappa-dKappaAve)/dKappaAve
            <<std::setw(nWidthOutputField)<<dGamma<<std::setw(nWidthOutputField)
            <<(dGamma-dGammaAve)/dGammaAve<<std::endl;//8
        }
        else{
          
          //get P
          dP=dGrid[nD][i][nPlaneIndex][k]*(dGamma-1.0)*dGrid[nE][i][nPlaneIndex][k];
          
          //calculate Q
          dC=sqrt(dGamma*dP/dGrid[nD][i][nPlaneIndex][k]);
          dDVDtThreshold=dAVThreshold*dC;
          
          //Q0
          if(nNumDims>=1){
            if(i==nSizeX1){
              dDVDt=(dA_ip1half*dGrid[nU][i+1][nPlaneIndex][k]
                -dA_im1half*dGrid[nU][i][0][0])/dRSq_i;
            }
            else{
              dDVDt=(dA_ip1half*dGrid[nU][i+1][nPlaneIndex][k]
                -dA_im1half*dGrid[nU][i][nPlaneIndex][k])/dRSq_i;
            }
            if(dDVDt<-1.0*dDVDtThreshold){//being compressed
              dDVDt_mthreshold=dDVDt+dDVDtThreshold;
              dQ0=dASq*dGrid[nD][i][nPlaneIndex][k]*dDVDt_mthreshold*dDVDt_mthreshold;
            }
            else{
              dQ0=0.0;
            }
          }
          
          //Q1
          if(nNumDims>=2){
            if(nPlaneIndex==0){
              dDVDt=(dA_jp1half*dGrid[nV][i][nPlaneIndex][k]
                -dA_jm1half*dGrid[nV][i][nSizeY2-1][nPlaneIndex])/dA_j;
            }
            else{
              dDVDt=(dA_jp1half*dGrid[nV][i][nPlaneIndex][k]
                -dA_jm1half*dGrid[nV][i][nPlaneIndex-1][k])/dA_j;
            }
            if(dDVDt<-1.0*dDVDtThreshold){//being compressed
              dDVDt_mthreshold=dDVDt+dDVDtThreshold;
              dQ1=dASq*dGrid[nD][i][nPlaneIndex][k]
                *dDVDt_mthreshold*dDVDt_mthreshold;
            }
            else{
              dQ1=0.0;
            }
          }
          
          //Q2
          if(nNumDims==3){
            if(k==0){
              dDVDt=(dGrid[nW][i][nPlaneIndex][k]-dGrid[nW][i][nPlaneIndex][nSizeZ-1]);
            }
            else{
              dDVDt=(dGrid[nW][i][nPlaneIndex][k]-dGrid[nW][i][nPlaneIndex][k-1]);
            }
            if(dDVDt<-1.0*dDVDtThreshold){//being compressed
              dDVDt_mthreshold=dDVDt+dDVDtThreshold;
              dQ2=dASq*dGrid[nD][i][nPlaneIndex][k]*dDVDt_mthreshold*dDVDt_mthreshold;
            }
            else{
              dQ2=0.0;
            }
          }
          dQ=dQ0+dQ1+dQ2;
          
          ofFile
            <<std::setw(nWidthOutputField)<<dE<<std::setw(nWidthOutputField)<<(dE-dEAve)/dEAve
            <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)<<"-"
            <<std::setw(nWidthOutputField)<<dP<<std::setw(nWidthOutputField)<<(dP-dPAve)/dPAve;
          if(dQAve==0.0){/*if QAve is zero, this can only be the case if all Q's are zero in the 
            horizontal zone also*/
            ofFile
              <<std::setw(nWidthOutputField)<<dQ<<std::setw(nWidthOutputField)<<0.0;
          }
          else{
            ofFile
              <<std::setw(nWidthOutputField)<<dQ<<std::setw(nWidthOutputField)<<(dQ-dQAve)/dQAve;
          }
          ofFile
            <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)<<"-"
            <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)<<"-"<<std::endl;//8
        }
      }
      ofFile
        <<std::setw(nWidthOutputField)<<"-"
        <<std::setw(nWidthOutputField)<<"-"
        <<std::setw(nWidthOutputField)<<"-";
      if(nW!=-1){
        ofFile
          <<std::setw(nWidthOutputField)<<dGrid[nW][i][nPlaneIndex][0];
      }
      else{
        ofFile
          <<std::setw(nWidthOutputField)<<"-";
      }
      ofFile
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::endl;
    }
    for(int k=0;k<nSizeZ;k++){
      ofFile
        <<std::setw(nWidthOutputField)<<dGrid[nU][nSizeX2][nPlaneIndex][k]
        <<std::setw(nWidthOutputField)<<dGrid[nU0][nSizeX2][0][0]
        <<std::setw(nWidthOutputField)<<"-"
        <<std::setw(nWidthOutputField)<<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::setw(nWidthOutputField)<<"-"<<std::setw(nWidthOutputField)
        <<"-"
        <<std::endl;
    }
  }
  
  ofFile.close();
  for(int n=0;n<nNumVars;n++){
    delete [] nSize[n];
    delete [] nVarInfo[n];
  }
  delete [] nSize;
  delete [] nVarInfo;
}
watchzone readInWatchZone(std::string sFileName){
  
  watchzone watchzoneTemp;
  
  //open file
  std::ifstream ifIn;
  ifIn.open(sFileName.c_str());
  if(!ifIn.good()){
      std::stringstream ssTemp;
      ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<":"<<" file \""<<sFileName
        <<"\" didn't open properly\n";
      throw exception2(ssTemp.str());
  }
  
  //through out first and second lines
  std::string sLine;
  std::getline(ifIn,sLine);//first
  
  //check if it is adiabatic of gammalaw, by seeing if a gamma is given in first line
  size_t found;
  found=sLine.find("gamma");
  bool bIsGammaLaw=false;
  if(found!=std::string::npos){
    bIsGammaLaw=true;
  }
  
  std::getline(ifIn,sLine);//second
  //int i=0;
  int nTemp;
  ifIn>>nTemp;
  double dTemp;
  std::string sTemp;
  int nPosition;
  while(!ifIn.eof()){
    
    //read in time
    nPosition=ifIn.tellg();
    ifIn>>sTemp;
    if(sTemp.compare("-")!=0){
      ifIn.seekg(nPosition);
      ifIn>>dTemp;
      watchzoneTemp.vecdT.push_back(dTemp);
    }
    
    //read in u_ip1half
    nPosition=ifIn.tellg();
    ifIn>>sTemp;
    if(sTemp.compare("-")!=0){
      ifIn.seekg(nPosition);
      ifIn>>dTemp;
      watchzoneTemp.vecdU_ip1half.push_back(dTemp);
    }
    
    //read in u_im1half
    nPosition=ifIn.tellg();
    ifIn>>sTemp;
    if(sTemp.compare("-")!=0){
      ifIn.seekg(nPosition);
      ifIn>>dTemp;
      watchzoneTemp.vecdU_im1half.push_back(dTemp);
    }
    
    //read in u_0_ip1half
    nPosition=ifIn.tellg();
    ifIn>>sTemp;
    if(sTemp.compare("-")!=0){
      ifIn.seekg(nPosition);
      ifIn>>dTemp;
      watchzoneTemp.vecdU0_ip1half.push_back(dTemp);
    }
    
    //read in u_0_im1half
    nPosition=ifIn.tellg();
    ifIn>>sTemp;
    if(sTemp.compare("-")!=0){
      ifIn.seekg(nPosition);
      ifIn>>dTemp;
      watchzoneTemp.vecdU0_im1half.push_back(dTemp);
    }
    
    //read in Q0
    nPosition=ifIn.tellg();
    ifIn>>sTemp;
    if(sTemp.compare("-")!=0){
      ifIn.seekg(nPosition);
      ifIn>>dTemp;
      watchzoneTemp.vecdQ0.push_back(dTemp);
    }
    
    //read in v_jp1half
    nPosition=ifIn.tellg();
    ifIn>>sTemp;
    if(sTemp.compare("-")!=0){
      ifIn.seekg(nPosition);
      ifIn>>dTemp;
      watchzoneTemp.vecdV_jp1half.push_back(dTemp);
    }

    
    //read in v_jm1half
    nPosition=ifIn.tellg();
    ifIn>>sTemp;
    if(sTemp.compare("-")!=0){
      ifIn.seekg(nPosition);
      ifIn>>dTemp;
      watchzoneTemp.vecdV_jm1half.push_back(dTemp);
    }
    
    //read in Q1
    nPosition=ifIn.tellg();
    ifIn>>sTemp;
    if(sTemp.compare("-")!=0){
      ifIn.seekg(nPosition);
      ifIn>>dTemp;
      watchzoneTemp.vecdQ1.push_back(dTemp);
    }
    
    //read in w_kp1half
    nPosition=ifIn.tellg();
    ifIn>>sTemp;
    if(sTemp.compare("-")!=0){
      ifIn.seekg(nPosition);
      ifIn>>dTemp;
      watchzoneTemp.vecdW_kp1half.push_back(dTemp);
    }
    
    //read in w_km1half
    nPosition=ifIn.tellg();
    ifIn>>sTemp;
    if(sTemp.compare("-")!=0){
      ifIn.seekg(nPosition);
      ifIn>>dTemp;
      watchzoneTemp.vecdW_km1half.push_back(dTemp);
    }
        
    //read in Q2
    nPosition=ifIn.tellg();
    ifIn>>sTemp;
    if(sTemp.compare("-")!=0){
      ifIn.seekg(nPosition);
      ifIn>>dTemp;
      watchzoneTemp.vecdQ2.push_back(dTemp);
    }
    
    //read in R_ip1half
    nPosition=ifIn.tellg();
    ifIn>>sTemp;
    if(sTemp.compare("-")!=0){
      ifIn.seekg(nPosition);
      ifIn>>dTemp;
      watchzoneTemp.vecdR_ip1half.push_back(dTemp);
    }
    
    //read in R_im1half
    nPosition=ifIn.tellg();
    ifIn>>sTemp;
    if(sTemp.compare("-")!=0){
      ifIn.seekg(nPosition);
      ifIn>>dTemp;
      watchzoneTemp.vecdR_im1half.push_back(dTemp);
    }
    
    //read in density
    nPosition=ifIn.tellg();
    ifIn>>sTemp;
    if(sTemp.compare("-")!=0){
      ifIn.seekg(nPosition);
      ifIn>>dTemp;
      watchzoneTemp.vecdDensity.push_back(dTemp);
    }
    
    //read in density average
    nPosition=ifIn.tellg();
    ifIn>>sTemp;
    if(sTemp.compare("-")!=0){
      ifIn.seekg(nPosition);
      ifIn>>dTemp;
      watchzoneTemp.vecdDensityAve.push_back(dTemp);
    }
    
    //read in E
    nPosition=ifIn.tellg();
    ifIn>>sTemp;
    if(sTemp.compare("-")!=0){
      ifIn.seekg(nPosition);
      ifIn>>dTemp;
      watchzoneTemp.vecdE.push_back(dTemp);
    }
    
    //read in P
    nPosition=ifIn.tellg();
    ifIn>>sTemp;
    if(sTemp.compare("-")!=0){
      ifIn.seekg(nPosition);
      ifIn>>dTemp;
      watchzoneTemp.vecdP.push_back(dTemp);
    }
    
    //read in T
    nPosition=ifIn.tellg();
    ifIn>>sTemp;
    if(sTemp.compare("-")!=0){
      ifIn.seekg(nPosition);
      ifIn>>dTemp;
      watchzoneTemp.vecdTemp.push_back(dTemp);
    }
    
    //read in DelM_r_t0
    nPosition=ifIn.tellg();
    ifIn>>sTemp;
    if(sTemp.compare("-")!=0){
      ifIn.seekg(nPosition);
      ifIn>>dTemp;
      watchzoneTemp.vecdDelM_r_t0.push_back(dTemp);
    }
    
    //read in DelM_r
    nPosition=ifIn.tellg();
    ifIn>>sTemp;
    if(sTemp.compare("-")!=0){
      ifIn.seekg(nPosition);
      ifIn>>dTemp;
      watchzoneTemp.vecdDelM_r.push_back(dTemp);
    }
    
    //read in error in Del M_r
    nPosition=ifIn.tellg();
    ifIn>>sTemp;
    if(sTemp.compare("-")!=0){
      ifIn.seekg(nPosition);
      ifIn>>dTemp;
      watchzoneTemp.vecdErrorDelM_r.push_back(dTemp);
    }
    
    ifIn.ignore(80,'\n');//dump rest of line, including newline
    ifIn>>nTemp;//get line number of next line, will trigger EOF ahead of time
    //ifIn>>dTemp;
    //ifIn>>dTemp;
    //ifIn>>dTemp;
   /*std::cout //test reading
      <<vecdT[i]<<" "
      <<vecdU_ip1half[i]<<" "
      <<vecdU_im1half[i]<<" "
      <<vecdU0_ip1half[i]<<" "
      <<vecdU0_im1half[i]<<" "
      <<vecdR_ip1half[i]<<" "
      <<vecdR_im1half[i]<<" "
      <<vecdDensity[i]<<" "
      <<vecdE[i]<<" "
      <<vecdDelM_r_t0[i]<<" "
      <<vecdDelM_r[i]<<" "
      <<vecdErrorDelM_r[i]<<"\n";*/
    //i++;
  }
  return watchzoneTemp;
}
void computeFourierTrans(std::string sInFileName,std::string sOutFileName){
  
  //read in watchzone
  watchzone watchzoneIn=readInWatchZone(sInFileName);
  
  //interpolate dependent variable to evenly spaced times
  fftw_complex *in;
  in=(fftw_complex*) fftw_malloc(sizeof(fftw_complex)*watchzoneIn.vecdT.size());
  double dTInterp=(watchzoneIn.vecdT[watchzoneIn.vecdT.size()-1]-watchzoneIn.vecdT[0])
    /double(watchzoneIn.vecdT.size());
  unsigned int nIndexKeep=1;
  unsigned int nIndexCur=1;
  for(unsigned int i=0;i<watchzoneIn.vecdT.size();i++){
    
    //calculate time to interpolate to
    double dt=double(i)*dTInterp+watchzoneIn.vecdT[0];
    
    //find bracketing times, will be nIndexKeep, and nIndexKeep-1
    bool bFound=false;
    nIndexCur--;
    while(!bFound&&nIndexCur<watchzoneIn.vecdT.size()){
      if(watchzoneIn.vecdT[nIndexCur]>dt){
        nIndexKeep=nIndexCur;
        bFound=true;
      }
      nIndexCur++;
    }
    
    //if not found, say so
    if(!bFound){
      fftw_free(in);
      std::stringstream ssTemp;
      ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<":"<<" time interpolating to, "<<dt
        <<" out side data set.\n";
      throw exception2(ssTemp.str());
    }
    
    //do linear interpolation to dt
    in[i][0]=(watchzoneIn.vecdU_ip1half[nIndexKeep]-watchzoneIn.vecdU_ip1half[nIndexKeep-1])
      /(watchzoneIn.vecdT[nIndexKeep]-watchzoneIn.vecdT[nIndexKeep-1])*
      (dt-watchzoneIn.vecdT[nIndexKeep-1])+watchzoneIn.vecdU_ip1half[nIndexKeep-1];
  }
  
  //setup FFT plan
  fftw_complex *out;
  fftw_plan p;
  out=(fftw_complex*) fftw_malloc(sizeof(fftw_complex)*watchzoneIn.vecdT.size());
  p=fftw_plan_dft_1d(watchzoneIn.vecdT.size(),in,out,FFTW_FORWARD,FFTW_ESTIMATE);
  
  //do the FFT
  fftw_execute(p);
  
  //output to file
  std::ofstream ofOut;
  ofOut.open(sOutFileName.c_str());
  if(!ofOut.good()){
    std::stringstream ssTemp;
    ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<":"<<" unable to open the file \""
      <<sOutFileName<<"\"\n";
    throw exception2(ssTemp.str());
  }
  
  //write out the properly scaled transform
  for(unsigned int i=0;i<watchzoneIn.vecdT.size()/2;i++){
    ofOut<<double(i)/dTInterp/watchzoneIn.vecdT.size()
      <<" "<<sqrt(out[i][0]*out[i][0]+out[i][1]*out[i][1])/double(watchzoneIn.vecdT.size())*2.0<<" "
      <<atan2(out[i][1],out[i][0])<<std::endl;
  }
  
  //free memory
  fftw_destroy_plan(p);
  fftw_free(in); fftw_free(out);
}
void convertBinToLNA(std::string sFileName){
  
  //open input file
  if(sFileName.size()==0){
    std::stringstream ssTemp;
    ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
      <<":no input file specified\n";
    throw exception2(ssTemp.str(),INPUT);
  }
  if(sFileName.substr(sFileName.length()-4,4)==".txt"){
    //try it without extension
    sFileName=sFileName.substr(0,sFileName.length()-4);
  }
  std::ifstream ifFile;
  ifFile.open(sFileName.c_str(),std::ios::binary);
  if(!ifFile.good()){
    std::stringstream ssTemp;
    ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": input file \""
      <<sFileName<<"\" didn't open properly\n";
    throw exception2(ssTemp.str(),INPUT);
  }
  
  //check that it is a binary file
  char cTemp;
  ifFile.read((char*)(&cTemp),sizeof(char));
  if(cTemp!='b'){
    std::stringstream ssTemp;
    ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": input file \""
      <<sFileName<<"\" isn't a binary file.\n";
    throw exception2(ssTemp.str(),INPUT);
  }
  
  //check that it is the correct version
  int nTemp;
  ifFile.read((char*)(&nTemp),sizeof(int));
  if(nTemp!=nDumpFileVersion){
    std::stringstream ssTemp;
    ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": inpput file \""
      <<sFileName<<"\" version \""<<nTemp
      <<"\" isn't the supported version \""<<nDumpFileVersion<<"\".\n";
    throw exception2(ssTemp.str(),INPUT);
  }
  
  //open output file
  std::string sFileNameOut=sFileName+"_LNA.txt";
  std::ofstream ofFile;
  ofFile.open(sFileNameOut.c_str());
  if(!ofFile.good()){
    std::stringstream ssTemp;
    ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<": output file \""
      <<sFileNameOut<<" didn't open properly\n";
    throw exception2(ssTemp.str(),INPUT);
  }
  
  //read in binary input file and write out in LNA format
  
  //read in time
  double dTime;
  ifFile.read((char*)(&dTime),sizeof(double));
  
  //read in time step index
  int nTimeStepIndex;
  ifFile.read((char*)(&nTimeStepIndex),sizeof(int));
  
  //read in last timestep
  double dTimeStep1;
  ifFile.read((char*)(&dTimeStep1),sizeof(double));
  
  //read in last timestep
  double dTimeStep2;
  ifFile.read((char*)(&dTimeStep2),sizeof(double));
  
  //read in alpha
  double dAlpha;
  ifFile.read((char*)(&dAlpha),sizeof(double));
  
  //read in equation of state info
  int nGammaLaw;
  double dGamma;
  std::string sEOSTable;
  ifFile.read((char*)(&nGammaLaw),sizeof(int));
  if(nGammaLaw==0){
    ifFile.read((char*)(&dGamma),sizeof(double));
  }
  else{
    char *cBuffer=new char[nGammaLaw+1];
    ifFile.read(cBuffer,nGammaLaw*sizeof(char));
    cBuffer[nGammaLaw]='\0';
    sEOSTable=cBuffer;
    delete [] cBuffer;
  }
  
  //read in/write out artificial viscosity
  double dAV;
  ifFile.read((char*)(&dAV),sizeof(double));
  
  //read in/write out artificial viscosity threshold
  double dAVThreshold;
  ifFile.read((char*)(&dAVThreshold),sizeof(double));
  
  //read in global grid size
  int nSizeGlobe[3];
  ifFile.read((char*)(nSizeGlobe),3*sizeof(int));
  
  //figure out number of dimensions
  int nNumDims=1;
  if(nSizeGlobe[1]>1){
    nNumDims++;
  }
  if(nSizeGlobe[2]>1){
    nNumDims++;
  }
  
  //read in periodicity
  int nPeriodic[3];
  ifFile.read((char*)(nPeriodic),3*sizeof(int));
  
  //read in number of 1D Zones
  int nNum1DZones;
  ifFile.read((char*)(&nNum1DZones),sizeof(int));
  
  //read in number of ghostcells
  int nNumGhostCells;
  ifFile.read((char*)(&nNumGhostCells),sizeof(int));
  
  //read in number of grid variables
  int nNumVars;
  ifFile.read((char*)(&nNumVars),sizeof(int));
  
  //get variable info, and set grid sizes
  int **nSize=new int*[nNumVars];
  int **nVarInfo=new int*[nNumVars];
  for(int n=0;n<nNumVars;n++){
    nSize[n]=new int[3];
    nVarInfo[n]=new int[4];
    ifFile.read((char*)(nVarInfo[n]),(4)*sizeof(int));
    for(int l=0;l<3;l++){
      if(nVarInfo[n][l]==-1){//variable not defined in direction l
        nSize[n][l]=1;
      }
      else if(nVarInfo[n][l]==1&&nPeriodic[l]==0){//interface variable
        nSize[n][l]=nSizeGlobe[l]+1;
      }
      else{
        nSize[n][l]=nSizeGlobe[l];
      }
    }
  }
  
  ofFile<<" "<<nSize[5][0]+nNumGhostCells;
  ofFile.precision(5);
  if(nGammaLaw==0){
    ofFile<<"  "<<dGamma<<std::endl;
  }
  else{
    ofFile<<"  "<<-1.0<<std::endl;
  }
  std::vector<double> vecdDensity;
  std::vector<double> vecdEnergy_or_Temp;
  std::vector<double> vecdRadius;
  std::vector<double> vecdMass;
  
  //read in the grid
  for(int n=0;n<nNumVars;n++){
    int nGhostCellsX=1;
    if(nVarInfo[n][0]==-1){
      nGhostCellsX=0;
    }
    int nGhostCellsY=1;
    if(nVarInfo[n][1]==-1){
      nGhostCellsY=0;
    }
    int nGhostCellsZ=1;
    if(nVarInfo[n][2]==-1){
      nGhostCellsZ=0;
    }
    
    //read in 1D part of the grid
    int nSizeX=nGhostCellsX*(nNum1DZones+nNumGhostCells);/*may be need to +1 if only one proc 
      and variable in interface centered*/
    if (nVarInfo[n][0]==1&&nPeriodic[0]==0){
      nSizeX=nGhostCellsX*(nNum1DZones+1+nNumGhostCells);
    }
    int nSizeY=1;
    int nSizeZ=1;
    for(int i=0;i<nSizeX;i++){
      int nCount=0;
      double dSum=0;
      for(int j=0;j<nSizeY;j++){
        double *dRow=new double[nSizeZ];
        ifFile.read((char*)(dRow),nSizeZ*sizeof(double));
        for(int k=0;k<nSizeZ;k++){
          dSum+=dRow[k];
          nCount++;
        }
        delete [] dRow;
      }
      double dAverage=dSum/double(nCount);
      if(i>=nNumGhostCells){//remove inner ghost cells
        
        if(nNumDims==1){
          
          //get density
          if(n==3){
            vecdDensity.push_back(dAverage);
          }
          
          //get energy or temperature
          if(n==6){
            vecdEnergy_or_Temp.push_back(dAverage);
          }
          
          //get radius
          if(n==2){
            vecdRadius.push_back(dAverage);
          }
          
          //get interior mass
          if(n==0){
            vecdMass.push_back(dAverage);
          }
        }
        if(nNumDims==2){
          
          //get density
          if(n==4){
            vecdDensity.push_back(dAverage);
          }
          
          //get energy or temperature
          if(n==8){
            vecdEnergy_or_Temp.push_back(dAverage);
          }
          
          //get radius
          if(n==3){
            vecdRadius.push_back(dAverage);
          }
          
          //get interior mass
          if(n==0){
            vecdMass.push_back(dAverage);
          }
        }
        if(nNumDims==3){
          
          //get density
          if(n==5){
            vecdDensity.push_back(dAverage);
          }
          
          //get energy or temperature
          if(n==10){
            vecdEnergy_or_Temp.push_back(dAverage);
          }
          
          //get radius
          if(n==4){
            vecdRadius.push_back(dAverage);
          }
          
          //get interior mass
          if(n==0){
            vecdMass.push_back(dAverage);
          }
        }
      }
    }
    
    //raed in the rest of the grid
    nSizeX=nSize[n][0]+nGhostCellsX*(nNumGhostCells-nNum1DZones);
    if(nVarInfo[n][0]==1&&nPeriodic[0]==0){
      nSizeX=nSize[n][0]+nGhostCellsX*(nNumGhostCells-(nNum1DZones+1));
    }
    nSizeY=nSize[n][1]+nGhostCellsY*2*nNumGhostCells;
    nSizeZ=nSize[n][2]+nGhostCellsZ*2*nNumGhostCells;
    double *dTempArray=new double[nSizeZ];
    for(int i=0;i<nSizeX;i++){
      int nCount=0;
      double dSum=0;
      for(int j=0;j<nSizeY;j++){
        if(ifFile.eof()){
          std::stringstream ssTemp;
          ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__
            <<": reached end of file sooner than expected\n";
          throw exception2(ssTemp.str(),INPUT);
        }
        ifFile.read((char*)(dTempArray),(nSizeZ)*sizeof(double));
        for(int k=0;k<nSizeZ;k++){
          dSum+=dTempArray[k];
          nCount++;
        }
      }
      double dAverage=dSum/double(nCount);
        
        if(nNumDims==1){
          
          //get density
          if(n==3){
            vecdDensity.push_back(dAverage);
          }
          
          //get energy or temperature
          if(n==6){
            vecdEnergy_or_Temp.push_back(dAverage);
          }
          
          //get radius
          if(n==2){
            vecdRadius.push_back(dAverage);
          }
          
          //get interior mass
          if(n==0){
            vecdMass.push_back(dAverage);
          }
        }
        if(nNumDims==2){
          
          //get density
          if(n==4){
            vecdDensity.push_back(dAverage);
          }
          
          //get energy or temperature
          if(n==8){
            vecdEnergy_or_Temp.push_back(dAverage);
          }
          
          //get radius
          if(n==3){
            vecdRadius.push_back(dAverage);
          }
          
          //get interior mass
          if(n==0){
            vecdMass.push_back(dAverage);
          }
        }
        if(nNumDims==3){
          
          //get density
          if(n==5){
            vecdDensity.push_back(dAverage);
          }
          
          //get energy or temperature
          if(n==10){
            vecdEnergy_or_Temp.push_back(dAverage);
          }
          
          //get radius
          if(n==4){
            vecdRadius.push_back(dAverage);
          }
          
          //get interior mass
          if(n==0){
            vecdMass.push_back(dAverage);
          }
        }
    }
    delete [] dTempArray;
    
  }
  
  //write rest of LNA file
  for(unsigned int i=0;i<vecdDensity.size();i++){
    int nLogDensity=int(log10(vecdDensity[i]));
    if(nLogDensity<0){
      nLogDensity=nLogDensity-1;
    }
    double dDensity=vecdDensity[i]/pow(10.0,double(nLogDensity));

    int nLogEnergy=int(log10(vecdEnergy_or_Temp[i]));
    double dEnergy=vecdEnergy_or_Temp[i]/pow(10.0,double(nLogEnergy));
    
    double dRadius=(vecdRadius[i+1]+vecdRadius[i])/2.0;
    int nLogRadius=int(log10(dRadius));
    dRadius=dRadius/pow(10.0,double(nLogRadius));
    
    double dMass=(vecdMass[i+1]+vecdMass[i])/2.0;
    int nLogMass=int(log10(dMass));
    dMass=dMass/pow(10.0,double(nLogMass));
    
    //write out density
    ofFile.setf(std::ios::fixed,std::ios::floatfield);
    ofFile.precision(12);
    ofFile<<"  "<<std::setw(14)<<dDensity<<"D";
    ofFile.precision(0);
    if(nLogDensity>=0){
      ofFile<<"+";
      ofFile<<std::setfill('0')<<std::setw(2)<<nLogDensity<<"  ";
    }
    else{
      ofFile<<"-";
      ofFile<<std::setfill('0')<<std::setw(2)<<-1*nLogDensity<<"  ";
    }
    
    //write out energy
    ofFile.precision(12);
    ofFile<<dEnergy<<"D";
    ofFile.precision(0);
    if(nLogEnergy>=0){
      ofFile<<"+";
      ofFile<<std::setfill('0')<<std::setw(2)<<nLogEnergy<<"  ";
    }
    else{
      ofFile<<"-";
      ofFile<<std::setfill('0')<<std::setw(2)<<-1*nLogEnergy<<"  ";
    }
    
    
    //write out radius
    ofFile.precision(12);
    ofFile<<dRadius<<"D";
    ofFile.precision(0);
    if(nLogEnergy>=0){
      ofFile<<"+";
      ofFile<<std::setfill('0')<<std::setw(2)<<nLogRadius<<"  ";
    }
    else{
      ofFile<<"-"<<std::setfill('0')<<std::setw(2)<<-1*nLogRadius<<"  ";
    }
    
    //write out mass
    ofFile.precision(12);
    ofFile<<dMass<<"D";
    ofFile.precision(0);
    if(nLogMass>=0){
      ofFile<<"+";
      ofFile<<std::setfill('0')<<std::setw(2)<<nLogMass<<std::endl;
    }
    else{
      ofFile<<"-";
      ofFile<<std::setfill('0')<<std::setw(2)<<-1*nLogMass<<std::endl;
    }
  }
  
  ifFile.close();
  ofFile.close();
  for(int n=0;n<nNumVars;n++){
    delete [] nSize[n];
    delete [] nVarInfo[n];
  }
  delete [] nSize;
  delete [] nVarInfo;
}
void computeFourierTransFromList(std::string sInFileName,std::string sOutFileName){

  //read in file list
  std::vector<double>vecdTimes;
  std::vector<double>vecdQuantity;
  std::ifstream ifInputFile;
  ifInputFile.open(sInFileName.c_str());
  if(!ifInputFile.good()){
    std::stringstream ssTemp;
    ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<":"<<" unable to open the file \""
      <<sInFileName<<"\"\n";
    throw exception2(ssTemp.str());
  }
  double dTemp1;
  double dTemp2;
  while(!ifInputFile.eof()){
    ifInputFile>>dTemp1>>dTemp2;
    vecdTimes.push_back(dTemp1);
    vecdQuantity.push_back(dTemp2);
  }
  
  //interpolate dependent variable to evenly spaced times
  fftw_complex *in;
  in=(fftw_complex*) fftw_malloc(sizeof(fftw_complex)*vecdTimes.size());
  double dTInterp=(vecdTimes[vecdTimes.size()-1]-vecdTimes[0])
    /double(vecdTimes.size());
  unsigned int nIndexKeep=1;
  unsigned int nIndexCur=1;
  for(unsigned int i=0;i<vecdTimes.size();i++){
    
    //calculate time to interpolate to
    double dt=double(i)*dTInterp+vecdTimes[0];
    
    //find bracketing times, will be nIndexKeep, and nIndexKeep-1
    bool bFound=false;
    nIndexCur--;
    while(!bFound&&nIndexCur<vecdTimes.size()){
      if(vecdTimes[nIndexCur]>dt){
        nIndexKeep=nIndexCur;
        bFound=true;
      }
      nIndexCur++;
    }
    
    //if not found, say so
    if(!bFound){
      fftw_free(in);
      std::stringstream ssTemp;
      ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<":"<<" time interpolating to, "<<dt
        <<" out side data set.\n";
      throw exception2(ssTemp.str());
    }
    
    //do linear interpolation to dt
    in[i][0]=(vecdQuantity[nIndexKeep]-vecdQuantity[nIndexKeep-1])
      /(vecdTimes[nIndexKeep]-vecdTimes[nIndexKeep-1])*
      (dt-vecdTimes[nIndexKeep-1])+vecdQuantity[nIndexKeep-1];
  }
  
  //setup FFT plan
  fftw_complex *out;
  fftw_plan p;
  out=(fftw_complex*) fftw_malloc(sizeof(fftw_complex)*vecdTimes.size());
  p=fftw_plan_dft_1d(vecdTimes.size(),in,out,FFTW_FORWARD,FFTW_ESTIMATE);
  
  //do the FFT
  fftw_execute(p);
  
  //output to file
  std::ofstream ofOut;
  ofOut.open(sOutFileName.c_str());
  if(!ofOut.good()){
    std::stringstream ssTemp;
    ssTemp<<__FILE__<<":"<<__FUNCTION__<<":"<<__LINE__<<":"<<" unable to open the file \""
      <<sOutFileName<<"\"\n";
    throw exception2(ssTemp.str());
  }
  
  //write out the properly scaled transform
  for(unsigned int i=0;i<vecdTimes.size()/2;i++){
    ofOut<<double(i)/dTInterp/vecdTimes.size()
      <<" "<<sqrt(out[i][0]*out[i][0]+out[i][1]*out[i][1])/double(vecdTimes.size())*2.0<<" "
      <<atan2(out[i][1],out[i][0])<<std::endl;
  }
  
  //free memory
  fftw_destroy_plan(p);
  fftw_free(in); fftw_free(out);
}
